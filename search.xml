<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ARTS 0x00 week</title>
    <url>/2019/03/17/ARTS-0x00-week/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>ARTS</title>
    <url>/2019/03/17/ARTS/</url>
    <content><![CDATA[<p>加入极客时间《左耳听风》第3期 ARTS 打卡小组</p>
<a id="more"></a>

<h1 id="ARTS-定义"><a href="#ARTS-定义" class="headerlink" title="ARTS 定义"></a>ARTS 定义</h1><ul>
<li>Algorithm：主要是为了编程训练和学习。每周至少做一个 leetcode 的算法题（先从Easy开始，然后再Medium，最后才Hard）。进行编程训练，如果不训练你看再多的算法书，你依然不会做算法题，看完书后，你需要训练。关于做Leetcode的的优势，你可以看一下我在coolshell上的文章 <a href="https://coolshell.cn/articles/12052.html">Leetcode 编程训练 - 酷 壳 - CoolShell</a>。</li>
<li>Review：主要是为了学习英文，如果你的英文不行，你基本上无缘技术高手。所以，需要你阅读并点评至少一篇英文技术文章，我个人最喜欢去的地方是 <a href="http://medium.com/">http://Medium.com</a> （需要梯子）以及各个公司的技术 blog，如 Netflix 的。</li>
<li>Tip：主要是为了总结和归纳你在是常工作中所遇到的知识点。学习至少一个技术技巧。你在工作中遇到的问题，踩过的坑，学习的点滴知识。</li>
<li>Share：主要是为了建立你的影响力，能够输出价值观。分享一篇有观点和思考的技术文章。</li>
</ul>
<h1 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h1><ul>
<li>（1）每周至少做一个 leetcode 的算法题</li>
<li>（2）阅读并点评至少一篇英文技术文章</li>
<li>（3）学习至少一个技术技巧</li>
<li>（4）分享一篇有观点和思考的技术文章</li>
</ul>
<blockquote>
<p>目前主要从事后端开发，主要使用 C/C++ 开发，目前逐渐开始过渡使用 Golang。希望通过这种坚持写下来分享的方式，来敦促自己进步！</p>
</blockquote>
]]></content>
      <categories>
        <category>ARTS</category>
      </categories>
      <tags>
        <tag>ARTS</tag>
      </tags>
  </entry>
  <entry>
    <title>DB2配置远程数据库</title>
    <url>/2019/10/24/DB2%E9%85%8D%E7%BD%AE%E8%BF%9C%E7%A8%8B%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<p>在DB2客户机上连接远程DB2服务之前，必须正确设置服务端通信协议。DB2支持的协议有TCP/IP、NetBIOS、NPIPE等。</p>
<p>基本分成2步：</p>
<ol>
<li>在客户机上对远程DB2节点进行设置。</li>
<li>在客户机上对远程数据库进行设置。</li>
</ol>
<a id="more"></a>

<h1 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h1><p>首先在客户机上对远程节点进行设置，这里需要确认远程主机在客户机上的名称、IP地址、端口号等基本命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">db2 =&gt; catalog tcpip node <span class="variable">$&#123;nodename&#125;</span> remote <span class="variable">$&#123;ip/hostname&#125;</span> server <span class="variable">$&#123;prot&#125;</span>  <span class="comment"># $&#123;nodename&#125; 不能超过8个字符</span></span><br><span class="line">db2 =&gt; TERMINATE                   <span class="comment">#刷新目录高速缓存</span></span><br><span class="line">db2 =&gt; LIST NODE DIRECTORY         <span class="comment">#查看客户机目录节点</span></span><br><span class="line">db2 =&gt; UNCATALOG NODE <span class="variable">$&#123;nodename&#125;</span>  <span class="comment">#查看客户机目录节点</span></span><br></pre></td></tr></table></figure>
<h1 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h1><p>再把远程节点上的数据库，设置本地别名</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">db2 =&gt; catalog db <span class="variable">$&#123;remote_dbname&#125;</span> as <span class="variable">$&#123;local_alias_name&#125;</span> at node <span class="variable">$&#123;nodename&#125;</span></span><br><span class="line">db2 =&gt; TERMINATE                         <span class="comment">#刷新目录高速缓存</span></span><br><span class="line">db2 =&gt; LIST DB DIRECTORY                 <span class="comment">#查看本地数据库目录</span></span><br><span class="line">db2 =&gt; UNCATALOG DB <span class="variable">$&#123;local_alias_name&#125;</span>  <span class="comment">#删除数据库编目$&#123;local_alias_name&#125; </span></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>DB2</tag>
      </tags>
  </entry>
  <entry>
    <title>Go 空结构体比较</title>
    <url>/2019/04/23/Go%E7%A9%BA%E7%BB%93%E6%9E%84%E4%BD%93%E6%AF%94%E8%BE%83/</url>
    <content><![CDATA[<h1 id="下面代码的输出是什么（判断-a-b-）的部分？为什么？"><a href="#下面代码的输出是什么（判断-a-b-）的部分？为什么？" class="headerlink" title="下面代码的输出是什么（判断 a == b ）的部分？为什么？"></a>下面代码的输出是什么（判断 a == b ）的部分？为什么？</h1><a id="more"></a>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 由于 struct 里面是空的，所以2个 struct 的地址可能会相同</span></span><br><span class="line">    a := &amp;<span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">	b := &amp;<span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a,b 里面的值都是空 struct 的地址，所以一样</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%p\n&quot;</span>, a)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%p\n&quot;</span>, b)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a,b 是不同的变量，本身的地址不同</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%p\n&quot;</span>, &amp;a)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%p\n&quot;</span>, &amp;b)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// true</span></span><br><span class="line">	fmt.Println(a == b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>引申 切片的引用</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">100</span>)</span><br><span class="line">	b := a</span><br><span class="line"></span><br><span class="line">	a[<span class="number">10</span>] = <span class="string">&#x27;y&#x27;</span></span><br><span class="line">	b[<span class="number">10</span>] = <span class="string">&#x27;x&#x27;</span></span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;a[10] =&quot;</span>, a[<span class="number">10</span>])</span><br><span class="line">	fmt.Println(<span class="string">&quot;b[10] =&quot;</span>, b[<span class="number">10</span>])</span><br><span class="line"></span><br><span class="line">	c := [<span class="number">3</span>]<span class="keyword">byte</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">	d := c</span><br><span class="line"></span><br><span class="line">	c[<span class="number">2</span>] = <span class="string">&#x27;x&#x27;</span></span><br><span class="line">	d[<span class="number">2</span>] = <span class="string">&#x27;y&#x27;</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;c[2] =&quot;</span>, c[<span class="number">2</span>])</span><br><span class="line">	fmt.Println(<span class="string">&quot;d[2] =&quot;</span>, d[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">	g := c[:]</span><br><span class="line">	h := g</span><br><span class="line"></span><br><span class="line">	g[<span class="number">2</span>] = <span class="string">&#x27;x&#x27;</span></span><br><span class="line">	h[<span class="number">2</span>] = <span class="string">&#x27;y&#x27;</span></span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;g[2] = &quot;</span>, g[<span class="number">2</span>])</span><br><span class="line">	fmt.Println(<span class="string">&quot;h[2] = &quot;</span>, h[<span class="number">2</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Output</span></span><br><span class="line"><span class="comment">a[10] = 120</span></span><br><span class="line"><span class="comment">b[10] = 120</span></span><br><span class="line"><span class="comment">c[2] = 120</span></span><br><span class="line"><span class="comment">d[2] = 121</span></span><br><span class="line"><span class="comment">g[2] =  121</span></span><br><span class="line"><span class="comment">h[2] =  121</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Go防缓存击穿 singleflight</title>
    <url>/2020/03/15/Go%E9%98%B2%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BFsingleflight/</url>
    <content><![CDATA[<h1 id="缓存更新问题"><a href="#缓存更新问题" class="headerlink" title="缓存更新问题"></a>缓存更新问题</h1><p>缓存是高并发业务的基石，当访问量突然上升的时候，缓存失效回源时会将请求打到后台数据库，导致服务器响应延迟或者宕机的情况。</p>
<p><code>通常缓存更新方案：</code></p>
<ul>
<li>1.业务代码中，根据key从缓存拿不到数据，访问存储层获取数据后更新缓存</li>
<li>2.由专门的定时脚本在缓存失效前对其进行更新</li>
<li>3.通过分布式锁，实现只有一个请求负责缓存更新，其他请求等待：<a href="http://yangxikun.github.io/%E7%BC%93%E5%AD%98/2015/07/02/cache-access.html">一种基于哨兵的缓存访问策略</a></li>
</ul>
<p>通常获取缓存这样写：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">data = getCache(key)</span><br><span class="line"><span class="keyword">if</span> !data &#123;</span><br><span class="line">    data = selectDB(key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h1 id="并发获取"><a href="#并发获取" class="headerlink" title="并发获取"></a>并发获取</h1><p>当缓存失效，集中查询DB时，此时需要考虑加锁。</p>
<h2 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkAccess</span><span class="params">(key)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    startTime = time.now()</span><br><span class="line">    <span class="keyword">for</span> <span class="literal">true</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> isLock(key) == <span class="literal">false</span> &#123;</span><br><span class="line">            setLock(key)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (time.now() - startTime) &gt; _maxLockTime &#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        time.sleep(<span class="number">20</span>ms)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在读取缓存失败，查询 DB 之前，先来一个锁判断，如果锁不存在，那么就加把锁，再去查 DB。如果锁存在，那么就等待，然后回头再去读 redis 或者进入 DB 查询。</p>
<h2 id="singleflight"><a href="#singleflight" class="headerlink" title="singleflight"></a>singleflight</h2><p>上面的代码使用起来没什么问题，但是依靠无限循环 + sleep 实现的方法比较低效。而在 go 语言中，借助非常轻量和高效的协程，可以很优雅的实现这种功能，这就是 <a href="https://github.com/golang/groupcache/tree/master/singleflight">singleflight</a>。</p>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>使用方法很简单，可以参考其<a href="https://github.com/golang/groupcache/blob/master/singleflight/singleflight_test.go">test</a> ：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestDo</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> g Group</span><br><span class="line">    v, err := g.Do(<span class="string">&quot;key&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;bar&quot;</span>, <span class="literal">nil</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">if</span> got, want := fmt.Sprintf(<span class="string">&quot;%v (%T)&quot;</span>, v, v), <span class="string">&quot;bar (string)&quot;</span>; got != want &#123;</span><br><span class="line">        t.Errorf(<span class="string">&quot;Do = %v; want %v&quot;</span>, got, want)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        t.Errorf(<span class="string">&quot;Do error = %v&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见使用起来非常简单，对外只需要这个Do 函数，传入 Key 和获取缓存的回调函数，如此 singleflight 就能自动帮我们处理同时请求下游服务的问题了。</p>
<p>那么这个Do函数到底做了什么事情？</p>
<p>源码分析</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> call <span class="keyword">struct</span> &#123;</span><br><span class="line">    wg sync.WaitGroup</span><br><span class="line">    val <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    err error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Group <span class="keyword">struct</span> &#123;</span><br><span class="line">    mu sync.Mutex       <span class="comment">// protects m</span></span><br><span class="line">    m  <span class="keyword">map</span>[<span class="keyword">string</span>]*call <span class="comment">// lazily initialized</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Group)</span> <span class="title">Do</span><span class="params">(key <span class="keyword">string</span>, fn <span class="keyword">func</span>()</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span>) <span class="params">(v <span class="keyword">interface</span>&#123;&#125;, err error, shared <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    g.mu.Lock()</span><br><span class="line">    <span class="keyword">if</span> g.m == <span class="literal">nil</span> &#123;</span><br><span class="line">        g.m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*call)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> c, ok := g.m[key]; ok &#123;</span><br><span class="line">        c.dups++</span><br><span class="line">        g.mu.Unlock()</span><br><span class="line">        c.wg.Wait()</span><br><span class="line">        <span class="keyword">return</span> c.val, c.err, <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    c := <span class="built_in">new</span>(call)</span><br><span class="line">    c.wg.Add(<span class="number">1</span>)</span><br><span class="line">    g.m[key] = c</span><br><span class="line">    g.mu.Unlock()</span><br><span class="line"></span><br><span class="line">    g.doCall(c, key, fn)</span><br><span class="line">    <span class="keyword">return</span> c.val, c.err, c.dups &gt; <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>go 的代码一直都很清晰易懂，可以看到先定义了结构体group和call，group.mu是保护group.m的互斥锁，group.m主要是保存请求的key，而call结构体是用来记录回调函数的结果。</p>
<p>在Do函数中，函数先是判断这个 key 是否是第一次调用，如果是，就会进入doCall调用回调函数获取结果，后续的请求就会阻塞在c.wg.Wait()这里，等待回调函数返回以后，直接拿到结果。</p>
<h3 id="singleflight-的应用"><a href="#singleflight-的应用" class="headerlink" title="singleflight 的应用"></a>singleflight 的应用</h3><p>所以依靠 singleflight ，针对并发缓存的更新，我们就可以这样实现：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">data = getCache(key)</span><br><span class="line"><span class="keyword">if</span> !data &#123;</span><br><span class="line">    data = g.Do(key, <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> selectDB(key)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Thanks"><a href="#Thanks" class="headerlink" title="Thanks"></a>Thanks</h1><p><a href="https://notes.wen.moe/2017/use-singleflight-instead-lock.html">使用 singleflight 代替传统的并发锁</a><br><a href="http://yangxikun.github.io/golang/2017/03/07/golang-singleflight.html">Golang singleflight 用武之地</a></p>
]]></content>
      <tags>
        <tag>cache</tag>
        <tag>go</tag>
        <tag>singleflight</tag>
      </tags>
  </entry>
  <entry>
    <title>Ticker资源泄露</title>
    <url>/2020/01/30/Ticker%E8%B5%84%E6%BA%90%E6%B3%84%E9%9C%B2/</url>
    <content><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>项目中遇到的一个问题，项目运行一段时间后CPU使用率会逐步上升到100%，导致系统异常，排查是在Ticker上使用出现错误，网上也有类似的案例：在使用Tikcer后没有释放导致。在此做下记录。</p>
<a id="more"></a>

<p>引用一段代码</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pinger)</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">    timeout := time.NewTicker(p.Timeout)    <span class="comment">// 创建Ticker timeout</span></span><br><span class="line">    interval := time.NewTicker(p.Interval)  <span class="comment">// 创建Ticker</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-p.done:       <span class="comment">// 正常退出，未关闭Ticker</span></span><br><span class="line">            wg.Wait()</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">case</span> &lt;-timeout.C:    <span class="comment">// 超时退出，未关闭Ticker</span></span><br><span class="line">            <span class="built_in">close</span>(p.done)</span><br><span class="line">            wg.Wait()</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">case</span> &lt;-interval.C:</span><br><span class="line">            <span class="keyword">if</span> p.Count &gt; <span class="number">0</span> &amp;&amp; p.PacketsSent &gt;= p.Count &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            err = p.sendICMP(conn)</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                fmt.Println(<span class="string">&quot;FATAL: &quot;</span>, err.Error())</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">case</span> r := &lt;-recv:</span><br><span class="line">            err := p.processPacket(r)</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                fmt.Println(<span class="string">&quot;FATAL: &quot;</span>, err.Error())</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> p.Count &gt; <span class="number">0</span> &amp;&amp; p.PacketsRecv &gt;= p.Count &#123;  <span class="comment">// 退出，未关闭Ticker</span></span><br><span class="line">            <span class="built_in">close</span>(p.done)</span><br><span class="line">            wg.Wait()</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>该段代码可以看出，这个函数是有出口的，但在出口处没有关闭Ticker，导致资源泄露。这个问题已经被修复了，可以看到修复后的局部代码如下：</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">timeout := time.NewTicker(p.Timeout)</span><br><span class="line"><span class="keyword">defer</span> timeout.Stop()  <span class="comment">// 使用defer保证Ticker最后被关闭</span></span><br><span class="line">interval := time.NewTicker(p.Interval)</span><br><span class="line"><span class="keyword">defer</span> interval.Stop() <span class="comment">// 使用defer保证Ticker最后被关闭</span></span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>有一种情况使用Ticker不主动关闭也不会造成资源泄露，比如，函数创建Ticker后就不会退出，直到进程结束。这种情况下不会持续的创建Ticker，也就不会造成资源泄露。</p>
<p>但是，不管哪种情况，创建一个Ticker后，紧跟着使用defer语句关闭Ticker总是好的习惯。因为，有可能别人无意间拷贝了你的部分代码，而忽略了关闭Ticker的动作。</p>
]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>协程</tag>
      </tags>
  </entry>
  <entry>
    <title>UNIX网络编程-卷2-源代码编译</title>
    <url>/2016/01/22/UNIX%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E5%8D%B72-%E6%BA%90%E4%BB%A3%E7%A0%81%E7%BC%96%E8%AF%91/</url>
    <content><![CDATA[<blockquote>
<p>最近在看《UNIX网络编程-第二版-卷2：进程间通讯》，下载了源码，在SLES SP4 32bit 无法编译，需要做些修改如下</p>
</blockquote>
<h2 id="1-下载源码"><a href="#1-下载源码" class="headerlink" title="1 下载源码:"></a>1 下载源码:</h2><p>W. Richard Stevens的主页：<a href="http://www.kohala.com/start/">http://www.kohala.com/start/</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget http://www.kohala.com/start/unpv22e/unpv22e.tar.gz -P /usr/<span class="built_in">local</span>/src</span><br></pre></td></tr></table></figure>
<h2 id="2-解压"><a href="#2-解压" class="headerlink" title="2 解压"></a>2 解压</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar xvf /usr/<span class="built_in">local</span>/src/unpv22e.tar.gz -C /root/bin</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h2 id="3-编译库文件，及修改头文件"><a href="#3-编译库文件，及修改头文件" class="headerlink" title="3 编译库文件，及修改头文件"></a>3 编译库文件，及修改头文件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /root/bin/unpv22e/</span><br><span class="line">./configure</span><br></pre></td></tr></table></figure>
<h3 id="3-1-修改生成config-h文件，注释以下几行"><a href="#3-1-修改生成config-h文件，注释以下几行" class="headerlink" title="3.1 修改生成config.h文件，注释以下几行"></a>3.1 修改生成config.h文件，注释以下几行</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">vi config.h</span><br><span class="line"><span class="number">56</span> <span class="comment">// #define uint8_t unsigned char</span></span><br><span class="line"><span class="number">57</span> <span class="comment">// #define uint16_t unsigned short</span></span><br><span class="line"><span class="number">58</span> <span class="comment">// #define uint32_t unsigned int</span></span><br></pre></td></tr></table></figure>
<h3 id="3-2-添加MSG-R和MSG-W定义"><a href="#3-2-添加MSG-R和MSG-W定义" class="headerlink" title="3.2 添加MSG_R和MSG_W定义"></a>3.2 添加MSG_R和MSG_W定义</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">vi config.h</span><br><span class="line"><span class="number">67</span> <span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">ulong_t</span>;</span><br><span class="line"><span class="number">68</span> <span class="meta">#<span class="meta-keyword">define</span> MSG_R 0400</span></span><br><span class="line"><span class="number">69</span> <span class="meta">#<span class="meta-keyword">define</span> MSG_W 0200</span></span><br></pre></td></tr></table></figure>
<h3 id="3-3-添加-GNU-SOURCE定义"><a href="#3-3-添加-GNU-SOURCE定义" class="headerlink" title="3.3 添加_GNU_SOURCE定义"></a>3.3 添加_GNU_SOURCE定义</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">vi config.h</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br></pre></td></tr></table></figure>
<h3 id="3-4-编译warpunix-c，使用mkstemp函数替换mktemp函数"><a href="#3-4-编译warpunix-c，使用mkstemp函数替换mktemp函数" class="headerlink" title="3.4 编译warpunix.c，使用mkstemp函数替换mktemp函数"></a>3.4 编译warpunix.c，使用mkstemp函数替换mktemp函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">cd lib</span><br><span class="line"><span class="number">181</span> <span class="keyword">void</span></span><br><span class="line"><span class="number">182</span> Mktemp(<span class="keyword">char</span> *<span class="keyword">template</span>)</span><br><span class="line"><span class="number">183</span> &#123;</span><br><span class="line"><span class="number">184</span> <span class="keyword">if</span> (mkstemp(<span class="keyword">template</span>) == <span class="literal">NULL</span> || <span class="keyword">template</span>[<span class="number">0</span>] == <span class="number">0</span>)</span><br><span class="line"><span class="number">185</span> err_quit(<span class="string">&quot;mktemp error&quot;</span>);</span><br><span class="line"><span class="number">186</span> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-5-编译生成libunpipc-a"><a href="#3-5-编译生成libunpipc-a" class="headerlink" title="3.5 编译生成libunpipc.a"></a>3.5 编译生成libunpipc.a</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> lib</span><br><span class="line">make</span><br></pre></td></tr></table></figure>
<h2 id="4-构建自己的编写代码的目录"><a href="#4-构建自己的编写代码的目录" class="headerlink" title="4 构建自己的编写代码的目录"></a>4 构建自己的编写代码的目录</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir -p /root/bin/unpv2</span><br><span class="line"><span class="built_in">cd</span> -</span><br><span class="line">cp /root/bin/unpv22e/libunpipc.a /root/bin/unpv22e/config.h /root/bin/unpv22e/Make.defines .</span><br></pre></td></tr></table></figure>
<h2 id="5-编译各个目录自己的文件"><a href="#5-编译各个目录自己的文件" class="headerlink" title="5 编译各个目录自己的文件"></a>5 编译各个目录自己的文件</h2><p>复制各个子目录下得*.h头文件和Makfile文件，然后执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cp /root/bin/unpv22e/dir/*.h /root/bin/unpv22e/dir/Makefile /root/bin/unpv2</span><br><span class="line">make filename</span><br></pre></td></tr></table></figure>
<p>即可编译各个子目录下的代码</p>
]]></content>
      <tags>
        <tag>UNIX</tag>
        <tag>Source</tag>
      </tags>
  </entry>
  <entry>
    <title>docker安装DB2</title>
    <url>/2019/10/23/docker%E5%AE%89%E8%A3%85DB2/</url>
    <content><![CDATA[<h1 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h1><p><a href="https://hub.docker.com/r/ibmcom/db2">https://hub.docker.com/r/ibmcom/db2</a></p>
<blockquote>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull ibmcom/db2</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h1 id="数据持久化"><a href="#数据持久化" class="headerlink" title="数据持久化"></a>数据持久化</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker volume create db2-11.5</span><br></pre></td></tr></table></figure>
<h1 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h1><p>根据实际情况，执行设置 DB2INST1_PASSWORD、DBNAME、ENABLE_ORACLE_COMPATIBILITY、端口映射、及目录映射或者持久化</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">docker <span class="builtin-name">run</span> -itd --name db2_11.5 <span class="attribute">--privileged</span>=<span class="literal">true</span> -p 50000:50000 \</span><br><span class="line">        -e <span class="attribute">LICENSE</span>=accept \</span><br><span class="line">        -e <span class="attribute">DB2INST1_PASSWORD</span>=BxFgy1ybgGl4nT7m6lEV9KtcZdpCiKMg \</span><br><span class="line">        -e <span class="attribute">DBNAME</span>=pay \</span><br><span class="line">        -e <span class="attribute">ENABLE_ORACLE_COMPATIBILITY</span>=<span class="literal">true</span> \</span><br><span class="line">        -v db2-11.5:/database ibmcom/db2</span><br></pre></td></tr></table></figure>
<h1 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h1><blockquote>
<p>docker exec -ti db2_11.5 bash -c “su - root”</p>
</blockquote>
<h2 id="新建用户"><a href="#新建用户" class="headerlink" title="新建用户"></a>新建用户</h2><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">useradd payplus</span></span><br><span class="line"><span class="attribute">passwd payplus</span>  </span><br></pre></td></tr></table></figure>
<h2 id="创建schema"><a href="#创建schema" class="headerlink" title="创建schema"></a>创建schema</h2><blockquote>
<p>su - db2inst1</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 登录</span></span><br><span class="line">db2 connect to daifu user db2inst1 using BxFgy1ybgGl4nT7m6lEV9KtcZdpCiKMg</span><br><span class="line"><span class="comment"># 创建模式</span></span><br><span class="line">db2 create schema payplus authorization password </span><br><span class="line"><span class="comment"># 给用户赋权限</span></span><br><span class="line">db2 grant dbadm on database to user payplus </span><br></pre></td></tr></table></figure>
<h2 id="创建数据库例子"><a href="#创建数据库例子" class="headerlink" title="创建数据库例子"></a>创建数据库例子</h2><figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line">db2 <span class="keyword">create</span> db daifu <span class="keyword">on</span> /<span class="keyword">database</span>/daifu <span class="keyword">using</span> codeset GBK territory CN pagesize <span class="number">32</span> k</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>DB2</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>docker搭建oracle: [helowin/oracle_11g]</title>
    <url>/2019/10/28/docker%E6%90%AD%E5%BB%BAoracle-helowin-oracle-11g/</url>
    <content><![CDATA[<h1 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h1><blockquote>
<p><a href="https://cr.console.aliyun.com/images/cn-hangzhou/oracle11-helowin/oracle11-helowin/detail?accounttraceid=24cfa63bff0f483db7d63268686a7a32yabl">https://cr.console.aliyun.com/images/cn-hangzhou/oracle11-helowin/oracle11-helowin/detail?accounttraceid=24cfa63bff0f483db7d63268686a7a32yabl</a></p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull registry.cn-hangzhou.aliyuncs.com/helowin/oracle_11g</span><br><span class="line">docker tag  registry.cn-hangzhou.aliyuncs.com/helowin/oracle_11g oracle_11g</span><br><span class="line">docker rmi  registry.cn-hangzhou.aliyuncs.com/helowin/oracle_11</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h1 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d -p 1521:1521 --name oracle_11g oracle_11g</span><br></pre></td></tr></table></figure>
<h1 id="数据持久化"><a href="#数据持久化" class="headerlink" title="数据持久化"></a>数据持久化</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker volume create oracle-11g</span><br><span class="line">docker run -d -p 1521:1521 --name oracle_11g -v oracle-11g:/home/oracle/app/oracle/oradata/ oracle_11g </span><br></pre></td></tr></table></figure>
<h1 id="oracle默认参数"><a href="#oracle默认参数" class="headerlink" title="oracle默认参数"></a>oracle默认参数</h1><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">hostname:</span> <span class="string">localhost</span></span><br><span class="line"><span class="attr">port:</span> <span class="number">1521</span></span><br><span class="line"><span class="attr">sid:</span> <span class="string">helowin</span></span><br><span class="line"><span class="attr">username:</span> <span class="string">system</span></span><br><span class="line"><span class="attr">password:</span> <span class="string">helowin</span></span><br></pre></td></tr></table></figure>
<h1 id="修改默认参数"><a href="#修改默认参数" class="headerlink" title="修改默认参数"></a>修改默认参数</h1><h2 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it oracle_11g  bash -c <span class="string">&quot;su - root&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="修改-etc-profile"><a href="#修改-etc-profile" class="headerlink" title="修改 /etc/profile"></a>修改 /etc/profile</h2><blockquote>
<p>vi /etc/profile</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># add</span></span><br><span class="line"><span class="built_in">export</span> ORACLE_HOME=/home/oracle/app/oracle/product/11.2.0/dbhome_2</span><br><span class="line"><span class="built_in">export</span> ORACLE_SID=helowin</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$ORACLE_HOME</span>/bin:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 执行</span></span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br><span class="line">ln -s <span class="variable">$ORACLE_HOME</span>/bin/sqlplus /usr/bin</span><br></pre></td></tr></table></figure>
<h2 id="登录oracle数据库，修改密码"><a href="#登录oracle数据库，修改密码" class="headerlink" title="登录oracle数据库，修改密码"></a>登录oracle数据库，修改密码</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">su oracle</span><br><span class="line">sqlplus /nolog</span><br><span class="line">conn /as sysdba</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">user</span> <span class="keyword">system</span> <span class="keyword">identified</span> <span class="keyword">by</span> <span class="keyword">password</span>;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">user</span> <span class="keyword">sys</span> <span class="keyword">identified</span> <span class="keyword">by</span> <span class="keyword">password</span>;</span><br><span class="line"><span class="keyword">ALTER</span> PROFILE <span class="keyword">DEFAULT</span> <span class="keyword">LIMIT</span> PASSWORD_LIFE_TIME <span class="keyword">UNLIMITED</span>;</span><br></pre></td></tr></table></figure>
<h2 id="修改字符集"><a href="#修改字符集" class="headerlink" title="修改字符集"></a>修改字符集</h2><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"># 默认字符集 AL32UTF8 <span class="comment">--&gt; ZHS16GBK</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SQL</span>&gt; conn /<span class="keyword">as</span> sysdba</span><br><span class="line"><span class="keyword">SQL</span>&gt; shutdown <span class="keyword">immediate</span>;</span><br><span class="line"><span class="keyword">SQL</span>&gt; startup mount</span><br><span class="line"></span><br><span class="line"><span class="keyword">SQL</span>&gt; <span class="keyword">ALTER</span> <span class="keyword">SYSTEM</span> <span class="keyword">ENABLE</span> RESTRICTED <span class="keyword">SESSION</span>;</span><br><span class="line"><span class="keyword">SQL</span>&gt; <span class="keyword">ALTER</span> <span class="keyword">SYSTEM</span> <span class="keyword">SET</span> AQ_TM_PROCESSES=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">SQL</span>&gt; <span class="keyword">alter</span> <span class="keyword">database</span> <span class="keyword">open</span>;</span><br><span class="line"><span class="keyword">SQL</span>&gt; <span class="keyword">ALTER</span> <span class="keyword">DATABASE</span> <span class="type">CHARACTER</span> <span class="keyword">SET</span> ZHS16GBK;</span><br><span class="line">ERROR at <span class="type">line</span> <span class="number">1</span>:</span><br><span class="line">ORA<span class="number">-12712</span>: <span class="built_in">new</span> <span class="type">character</span> <span class="keyword">set</span> must be a superset <span class="keyword">of</span> <span class="built_in">old</span> <span class="type">character</span> <span class="keyword">set</span></span><br><span class="line">提示我们的字符集：新字符集必须为旧字符集的超集，这时我们可以跳过超集的检查做更改(但是已有数据这样做会乱码)：</span><br><span class="line"><span class="keyword">SQL</span>&gt; <span class="keyword">ALTER</span> <span class="keyword">DATABASE</span> <span class="type">character</span> <span class="keyword">set</span> INTERNAL_USE ZHS16GBK;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SQL</span>&gt; <span class="keyword">select</span> * <span class="keyword">from</span> v$nls_parameters;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SQL</span>&gt; shutdown <span class="keyword">immediate</span>;</span><br><span class="line"><span class="keyword">SQL</span>&gt; startup</span><br><span class="line"></span><br><span class="line">至此，字符集的修改就完成了，我们可以通过输入命令验证一下，其结果已经变成了ZHS16GBK了。</span><br><span class="line"><span class="keyword">SQL</span>&gt; <span class="keyword">select</span> userenv(<span class="string">&#x27;language&#x27;</span>) <span class="keyword">from</span> dual;</span><br></pre></td></tr></table></figure>

<h2 id="创建普通用户"><a href="#创建普通用户" class="headerlink" title="创建普通用户"></a>创建普通用户</h2><h3 id="用system登录"><a href="#用system登录" class="headerlink" title="用system登录"></a>用system登录</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> <span class="keyword">test</span> <span class="keyword">identified</span> <span class="keyword">by</span> <span class="number">123456</span>;</span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">connect</span>, <span class="keyword">resource</span>, dba <span class="keyword">to</span> <span class="keyword">test</span>;</span><br></pre></td></tr></table></figure>
<h3 id="使用普通用户登陆"><a href="#使用普通用户登陆" class="headerlink" title="使用普通用户登陆"></a>使用普通用户登陆</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询数据库名， 表名</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> v$<span class="keyword">database</span>;</span><br><span class="line"><span class="keyword">select</span> table_name <span class="keyword">from</span> all_tables  <span class="comment">-- where table_name like &#x27;%PER&#x27; ; --where ROWNUM &lt;10 ;</span></span><br></pre></td></tr></table></figure>
<h1 id="配置nginx：-反向代理oracle服务"><a href="#配置nginx：-反向代理oracle服务" class="headerlink" title="配置nginx： 反向代理oracle服务"></a>配置nginx： 反向代理oracle服务</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># nginx 反向代理</span></span><br><span class="line">stream &#123;    </span><br><span class="line">	upstream oracle&#123;</span><br><span class="line">		<span class="built_in">hash</span> <span class="variable">$remote_addr</span> consistent;</span><br><span class="line">		server 192.168.99.101:1521 max_fails=3 fail_timeout=30s;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	server &#123;</span><br><span class="line">		listen 1521;</span><br><span class="line">		proxy_connect_timeout 3000s;</span><br><span class="line">		proxy_timeout 6000s;</span><br><span class="line">		proxy_pass oracle;</span><br><span class="line">	&#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>1、网上还有针对sath89/oracle-xe-11g这个镜像的教程，需要注意的是：Oracle快捷版（Oracle XE）是一款基于 Oracle 11g 第2版代码库的小型入门级数据库。Oracle Database XE对安装主机的规模和CPU数量不作限制（每台计算机一个数据库）， 但XE将最多存储11GB的用户数据，同时最多使用1GB内存和主机上的一个CPU。</li>
<li>2、如果仅作测试也可以安装这个镜像，镜像大约700兆。而教程中的镜像大约近7G。</li>
<li>3、<a href="https://github.com/wnameless/docker-oracle-xe-11g">https://github.com/wnameless/docker-oracle-xe-11g</a></li>
</ul>
</blockquote>
]]></content>
      <tags>
        <tag>docker</tag>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>docker镜像自动编译程序</title>
    <url>/2019/10/12/docker%E9%95%9C%E5%83%8F%E8%87%AA%E5%8A%A8%E7%BC%96%E8%AF%91%E7%A8%8B%E5%BA%8F/</url>
    <content><![CDATA[<p>使用docker创建C++编译环境，自动创建二进制执行程序。</p>
<a id="more"></a>


<h1 id="docker-run-一次执行多条命令的方法"><a href="#docker-run-一次执行多条命令的方法" class="headerlink" title="docker run 一次执行多条命令的方法"></a>docker run 一次执行多条命令的方法</h1><p>有时在启动docker container时需要同时运行不止一条命令，这时在command处使用：sh -c ‘ cmd1 &amp;&amp; cmd2 ‘即可。</p>
<p>如，docker run -it myimage sh -c ‘service mysql start &amp;&amp; python test.py’</p>
<h1 id="编译-acl-rpm-包"><a href="#编译-acl-rpm-包" class="headerlink" title="编译 acl rpm 包"></a>编译 acl rpm 包</h1><h2 id="方法一：-创建-acl-编译镜像"><a href="#方法一：-创建-acl-编译镜像" class="headerlink" title="方法一： 创建 acl 编译镜像"></a>方法一： 创建 acl 编译镜像</h2><h3 id="编写-Dokcerfile"><a href="#编写-Dokcerfile" class="headerlink" title="编写 Dokcerfile"></a>编写 Dokcerfile</h3><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> centos:<span class="number">6.10</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> yum -y install gcc gcc-c++ zlib-devel git rpm-build</span></span><br></pre></td></tr></table></figure>
<h3 id="创建镜像"><a href="#创建镜像" class="headerlink" title="创建镜像"></a>创建镜像</h3><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">docker <span class="keyword">build </span>-t rpm-<span class="keyword">build-image </span>.</span><br></pre></td></tr></table></figure>
<h3 id="创建容器编译"><a href="#创建容器编译" class="headerlink" title="创建容器编译"></a>创建容器编译</h3><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 本地拉取</span></span><br><span class="line">git clone https:<span class="regexp">//gi</span>tee.com<span class="regexp">/acl-dev/</span>acl.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译宿主机代码</span></span><br><span class="line">docker run --rm -v <span class="string">&quot;$(pwd)&quot;</span>:<span class="regexp">/usr/</span>app<span class="regexp">/ -w /u</span>sr<span class="regexp">/app/</span>acl/packaging  rpm-build-image make</span><br></pre></td></tr></table></figure>
<p>or</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 保留git仓库</span></span><br><span class="line">docker run --rm -v <span class="string">&quot;$(pwd)&quot;</span><span class="symbol">:/usr/app/</span> -w /usr/app rpm-build-image sh -c <span class="string">&#x27;git clone https://gitee.com/acl-dev/acl.git &amp;&amp; cd acl/packaging &amp;&amp; make &#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 只保留rpm包</span></span><br><span class="line">docker run --rm -v <span class="string">&quot;$(pwd)&quot;</span><span class="symbol">:/usr/app/</span> rpm-build-image sh -c <span class="string">&#x27;git clone https://gitee.com/acl-dev/acl.git &amp;&amp; cd acl/packaging &amp;&amp; make &amp;&amp; mv x86_64 /usr/app&#x27;</span></span><br></pre></td></tr></table></figure>
<h2 id="方法二-不创建镜像，直接使用临时容器"><a href="#方法二-不创建镜像，直接使用临时容器" class="headerlink" title="方法二: 不创建镜像，直接使用临时容器"></a>方法二: 不创建镜像，直接使用临时容器</h2><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">docker <span class="keyword">run</span> --<span class="keyword">rm</span> -v <span class="string">&quot;$(pwd)&quot;</span>:/usr/<span class="keyword">app</span>/ centos:6.10 <span class="keyword">su</span> -c &#x27;yum -y install gcc gcc-c++ zlib-devel git rpm-build \</span><br><span class="line">&amp;&amp; git clone https:<span class="comment">//gitee.com/acl-dev/acl.git \</span></span><br><span class="line">&amp;&amp; <span class="keyword">cd</span> acl/packaging \</span><br><span class="line">&amp;&amp; make \</span><br><span class="line">&amp;&amp; mv x86_64 /usr/<span class="keyword">app</span>&#x27;</span><br></pre></td></tr></table></figure>

<h1 id="CentOS-nginx-添加-ngx-http-proxy-connect-module"><a href="#CentOS-nginx-添加-ngx-http-proxy-connect-module" class="headerlink" title="CentOS nginx 添加 ngx_http_proxy_connect_module"></a>CentOS nginx 添加 ngx_http_proxy_connect_module</h1><h2 id="更新系统软件到最新"><a href="#更新系统软件到最新" class="headerlink" title="更新系统软件到最新"></a>更新系统软件到最新</h2><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">yum -y update</span></span><br></pre></td></tr></table></figure>
<h2 id="安装编译环境："><a href="#安装编译环境：" class="headerlink" title="安装编译环境："></a>安装编译环境：</h2><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">yum -y install gcc gcc-c++ <span class="built_in">auto</span>make <span class="built_in">auto</span>conf libtool make rpm-build rpmdevtools rpmlint wget</span><br></pre></td></tr></table></figure>
<h2 id="安装Nginx所依赖的包："><a href="#安装Nginx所依赖的包：" class="headerlink" title="安装Nginx所依赖的包："></a>安装Nginx所依赖的包：</h2><figure class="highlight gml"><table><tr><td class="code"><pre><span class="line">yum -<span class="symbol">y</span> install -<span class="symbol">y</span> openssl-devel zlib-devel pcre-devel gd-devel</span><br></pre></td></tr></table></figure>
<h2 id="新建用户rpmbuild"><a href="#新建用户rpmbuild" class="headerlink" title="新建用户rpmbuild"></a>新建用户rpmbuild</h2><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="attribute">name</span>=rpmbuild</span><br><span class="line">useradd <span class="variable">$name</span></span><br><span class="line">echo <span class="string">&quot;<span class="variable">$name</span> ALL=(ALL) NOPASSWD:ALL&quot;</span> &gt;&gt; /etc/sudoers</span><br><span class="line">su - <span class="variable">$name</span></span><br></pre></td></tr></table></figure>
<h2 id="创建rpm目录"><a href="#创建rpm目录" class="headerlink" title="创建rpm目录"></a>创建rpm目录</h2><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">rpmdev-setuptree</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在rpmbuild的home目录下面有了这几个目录</span></span><br><span class="line"><span class="keyword">BUILD </span><span class="keyword">BUILDROOT </span>RPMS SOURCES SPECS SRPMS</span><br></pre></td></tr></table></figure>
<h2 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a>下载源码</h2><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">cd</span> ~/rpmbuild/SOURCES</span><br><span class="line"><span class="attribute">wget</span> http://nginx.org/packages/centos/<span class="number">7</span>/SRPMS/nginx-<span class="number">1</span>.<span class="number">16</span>.<span class="number">1</span>-<span class="number">1</span>.el<span class="number">7</span>.ngx.src.rpm</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压</span></span><br><span class="line"><span class="attribute">rpm2cpio</span> nginx-<span class="number">1</span>.<span class="number">16</span>.<span class="number">1</span>-<span class="number">1</span>.el<span class="number">7</span>.ngx.src.rpm |cpio -dvi</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="文件列表"><a href="#文件列表" class="headerlink" title="文件列表"></a>文件列表</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">COPYRIGHT</span> </span><br><span class="line"><span class="selector-tag">nginx-debug</span><span class="selector-class">.service</span>  <span class="selector-tag">nginx</span><span class="selector-class">.check-reload</span><span class="selector-class">.sh</span>  </span><br><span class="line"><span class="selector-tag">nginx</span><span class="selector-class">.init</span><span class="selector-class">.in</span>  <span class="selector-tag">nginx</span><span class="selector-class">.spec</span>            </span><br><span class="line"><span class="selector-tag">nginx</span><span class="selector-class">.sysconf</span>  <span class="selector-tag">nginx</span><span class="selector-class">.vh</span><span class="selector-class">.default</span><span class="selector-class">.conf</span></span><br><span class="line"><span class="selector-tag">logrotate</span>  <span class="selector-tag">nginx-1</span>.16.1<span class="selector-class">.tar</span><span class="selector-class">.gz</span></span><br><span class="line"><span class="selector-tag">nginx-debug</span><span class="selector-class">.sysconf</span>  <span class="selector-tag">nginx</span><span class="selector-class">.conf</span></span><br><span class="line"><span class="selector-tag">nginx</span><span class="selector-class">.service</span>  <span class="selector-tag">nginx</span><span class="selector-class">.suse</span><span class="selector-class">.logrotate</span></span><br><span class="line"><span class="selector-tag">nginx</span><span class="selector-class">.upgrade</span><span class="selector-class">.sh</span></span><br></pre></td></tr></table></figure>
<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 制作二进制包</span></span><br><span class="line">rpmbuild -bb nginx.<span class="keyword">spec</span> </span><br><span class="line"><span class="comment"># 表示既制作二进制包又制作src格式包</span></span><br><span class="line">rpmbuild -ba nginx.<span class="keyword">spec</span> </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="完成"><a href="#完成" class="headerlink" title="完成"></a>完成</h2><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ~/rpmbuild/RPMS/x86_64</span></span><br><span class="line"><span class="attribute">nginx</span>-<span class="number">1</span>.<span class="number">16</span>.<span class="number">1</span>-<span class="number">1</span>.el<span class="number">7</span>.ngx.x<span class="number">86</span>_<span class="number">64</span>.rpm</span><br><span class="line"><span class="attribute">nginx</span>-debuginfo-<span class="number">1</span>.<span class="number">16</span>.<span class="number">1</span>-<span class="number">1</span>.el<span class="number">7</span>.ngx.x<span class="number">86</span>_<span class="number">64</span>.rpm</span><br></pre></td></tr></table></figure>
<h2 id="patch-补丁-ngx-http-proxy-connect-module"><a href="#patch-补丁-ngx-http-proxy-connect-module" class="headerlink" title="patch 补丁 ngx_http_proxy_connect_module"></a>patch 补丁 ngx_http_proxy_connect_module</h2><p>example:</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">cd nginx-<span class="number">1.16</span>.<span class="number">1</span></span><br><span class="line">patch -p1 &lt; /nginx/ngx_http_proxy_connect_module-master/patch/proxy_connect_rewrite_101504.patch</span><br><span class="line"></span><br><span class="line">./configure <span class="string">\</span></span><br><span class="line">--add-<span class="built_in">module</span>=/nginx/ngx_http_proxy_connect_module-master <span class="string">\</span></span><br><span class="line">--<span class="keyword">with</span>-http_ssl_module <span class="string">\</span></span><br><span class="line">--<span class="keyword">with</span>-http_realip_module <span class="string">\</span></span><br><span class="line">--<span class="keyword">with</span>-http_addition_module <span class="string">\</span></span><br><span class="line">--<span class="keyword">with</span>-http_sub_module <span class="string">\</span></span><br><span class="line">--<span class="keyword">with</span>-http_dav_module <span class="string">\</span></span><br><span class="line">--<span class="keyword">with</span>-http_flv_module <span class="string">\</span></span><br><span class="line">--<span class="keyword">with</span>-http_mp4_module <span class="string">\</span></span><br><span class="line">--<span class="keyword">with</span>-http_gunzip_module <span class="string">\</span></span><br><span class="line">--<span class="keyword">with</span>-http_gzip_static_module <span class="string">\</span></span><br><span class="line">--<span class="keyword">with</span>-http_random_index_module <span class="string">\</span></span><br><span class="line">--<span class="keyword">with</span>-http_secure_link_module <span class="string">\</span></span><br><span class="line">--<span class="keyword">with</span>-http_stub_status_module <span class="string">\</span></span><br><span class="line">--<span class="keyword">with</span>-http_auth_request_module <span class="string">\</span></span><br><span class="line">--<span class="keyword">with</span>-threads --<span class="keyword">with</span>-stream <span class="string">\</span></span><br><span class="line">--<span class="keyword">with</span>-stream_ssl_module <span class="string">\</span></span><br><span class="line">--<span class="keyword">with</span>-http_slice_module <span class="string">\</span></span><br><span class="line">--<span class="keyword">with</span>-file-aio <span class="string">\</span></span><br><span class="line">--<span class="keyword">with</span>-http_v2_module <span class="string">\</span></span><br><span class="line">--user=nginx <span class="string">\</span></span><br><span class="line">--group=nginx</span><br><span class="line"></span><br><span class="line">make &amp;&amp; make install</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>docker</tag>
        <tag>acl</tag>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>getopt和getopt_long函数</title>
    <url>/2016/02/01/getopt%E5%92%8Cgetopt-long%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<blockquote>
<p>在linux下写程序时常常需要对命令行参数进行处理。下面比对下getopt、getopt_long、getopt_long_only。</p>
</blockquote>
<a id="more"></a>

<h3 id="头文件及函数声明"><a href="#头文件及函数声明" class="headerlink" title="头文件及函数声明"></a>头文件及函数声明</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getopt</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * <span class="keyword">const</span> argv[],</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">const</span> <span class="keyword">char</span> *optstring)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> *optarg;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> optind, opterr, optopt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;getopt.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getopt_long</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * <span class="keyword">const</span> argv[],</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">const</span> <span class="keyword">char</span> *optstring,</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">const</span> struct option *longopts, <span class="keyword">int</span> *longindex)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getopt_long_only</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * <span class="keyword">const</span> argv[],</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">const</span> <span class="keyword">char</span> *optstring,</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">const</span> struct option *longopts, <span class="keyword">int</span> *longindex)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>从最简单的getopt讲起，getopt函数的前两个参数，就是main函数的argc和argv，这两者直接传入即可，要考虑的就只剩下第三个参数。</strong></p>
<p>optstring的格式举例说明比较方便，例如：</p>
<pre><code>char *optstring = &quot;abcd:&quot;;</code></pre>
<p>上面这个optstring在传入之后，getopt函数将依次检查命令行是否指定了 -a， -b， -c及 -d（这需要多次调用getopt函数，直到其返回-1），当检查到上面某一个参数被指定时，函数会返回被指定的参数名称（即该字母）</p>
<p>最后一个参数d后面带有冒号: 表示参数d是可以指定值的，如 -d 100 或 -d user。</p>
<p>optind表示的是下一个将被处理到的参数在argv中的下标值。</p>
<p>如果指定opterr = 0的话，在getopt、getopt_long、getopt_long_only遇到错误将不会输出错误信息到标准输出流。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> opt;</span><br><span class="line">    <span class="keyword">char</span> *optstring = <span class="string">&quot;a:b:c:d&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((opt = getopt(argc, argv, optstring)) != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;opt = %c\n&quot;</span>, opt);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;optarg = %s\n&quot;</span>, optarg);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;optind = %d\n&quot;</span>, optind);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;argv[optind - 1] = %s\n\n&quot;</span>,  argv[optind - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译上述程序并运行，有如下结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cashey@ubuntu:~/Desktop/getopt$ ./test_getopt -a 100 -b 200 -c admin -d</span><br><span class="line">opt = a</span><br><span class="line">optarg = 100</span><br><span class="line">optind = 3</span><br><span class="line">argv[optind - 1] = 100</span><br><span class="line"></span><br><span class="line">opt = b</span><br><span class="line">optarg = 200</span><br><span class="line">optind = 5</span><br><span class="line">argv[optind - 1] = 200</span><br><span class="line"></span><br><span class="line">opt = c</span><br><span class="line">optarg = admin</span><br><span class="line">optind = 7</span><br><span class="line">argv[optind - 1] = admin</span><br><span class="line"></span><br><span class="line">opt = d</span><br><span class="line">optarg = (null)</span><br><span class="line">optind = 8</span><br><span class="line">argv[optind - 1] = -d</span><br></pre></td></tr></table></figure>
<p>** 下面来讲getopt_long函数，getopt_long函数包含了getopt函数的功能，并且还可以指定“长参数”（或者说长选项），与getopt函数对比，getopt_long比其多了两个参数： **</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getopt</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * <span class="keyword">const</span> argv[],</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">const</span> <span class="keyword">char</span> *optstring)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getopt_long</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * <span class="keyword">const</span> argv[],</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="keyword">const</span> <span class="keyword">char</span> *optstring,</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="keyword">const</span> struct option *longopts, <span class="keyword">int</span> *longindex)</span></span>;</span><br></pre></td></tr></table></figure>

<p>在这里，longopts指向的是一个由option结构体组成的数组，那个数组的每个元素，指明了一个“长参数”（即形如–name的参数）名称和性质：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">option</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">int</span>         has_arg;</span><br><span class="line">    <span class="keyword">int</span>        *flag;</span><br><span class="line">    <span class="keyword">int</span>         val;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<pre><code>   name     是参数的名称

   has_arg  指明是否带参数值，其数值可选：
            no_argument (即 0) 表明这个长参数不带参数（即不带数值，如：--name）
            required_argument (即 1) 表明这个长参数必须带参数（即必须带数值，如：--name Bob）
            optional_argument（即2）表明这个长参数后面带的参数是可选的，（即--name和--name Bob均可）

   flag     当这个指针为空的时候，函数直接将val的数值从getopt_long的返回值返回出去，当它非空时，
            val的值会被赋到flag指向的整型数中，而函数返回值为0

   val      用于指定函数找到该选项时的返回值，或者当flag非空时指定flag指向的数据的值。</code></pre>
<p>** 另一个参数longindex，如果longindex非空，它指向的变量将记录当前找到参数符合longopts里的第几个元素的描述，即是longopts的下标值。**</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;getopt.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">int</span> opt;</span><br><span class="line">   <span class="keyword">int</span> digit_optind = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">int</span> option_index = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">char</span> *optstring = <span class="string">&quot;a:b:c:d&quot;</span>;</span><br><span class="line">   <span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">option</span> <span class="title">long_options</span>[] =</span> &#123;</span><br><span class="line">       &#123;<span class="string">&quot;reqarg&quot;</span>, required_argument, <span class="literal">NULL</span>, <span class="string">&#x27;r&#x27;</span>&#125;,</span><br><span class="line">       &#123;<span class="string">&quot;noarg&quot;</span>,  no_argument,       <span class="literal">NULL</span>, <span class="string">&#x27;n&#x27;</span>&#125;,</span><br><span class="line">       &#123;<span class="string">&quot;optarg&quot;</span>, optional_argument, <span class="literal">NULL</span>, <span class="string">&#x27;o&#x27;</span>&#125;,</span><br><span class="line">       &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;</span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">while</span> ( (opt = getopt_long(argc, argv, optstring, long_options, &amp;option_index)) != <span class="number">-1</span>)</span><br><span class="line">   &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;opt = %c\n&quot;</span>, opt);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;optarg = %s\n&quot;</span>, optarg);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;optind = %d\n&quot;</span>, optind);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;argv[optind - 1] = %s\n&quot;</span>,  argv[optind - <span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;option_index = %d\n&quot;</span>, option_index);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>** 编译运行以上程序并运行，可以得到以下结果： **</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">cashey@ubuntu:~/Desktop/getopt$ ./test_getopt_long -a 100 --reqarg 100 --nonarg</span></span><br><span class="line">opt = a</span><br><span class="line">optarg = 100</span><br><span class="line">optind = 3</span><br><span class="line">argv[optind - 1] = 100</span><br><span class="line">option_index = 0</span><br><span class="line">opt = r</span><br><span class="line">optarg = 100</span><br><span class="line">optind = 5</span><br><span class="line">argv[optind - 1] = 100</span><br><span class="line">option_index = 0</span><br><span class="line"><span class="section">./test_getopt_long: unrecognized option &#x27;--nonarg&#x27;</span></span><br><span class="line">opt = ?</span><br><span class="line">optarg = (null)</span><br><span class="line">optind = 6</span><br><span class="line">argv[optind - 1] = --nonarg</span><br><span class="line">option_index = 0</span><br></pre></td></tr></table></figure>
<p>** 当所给的参数存在问题时，opt（即函数返回值是’?’），如： **</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">cashey<span class="variable">@ubuntu</span><span class="symbol">:~/Desktop/getopt</span><span class="variable">$ </span>./test_getopt_long -a</span><br><span class="line">./<span class="symbol">test_getopt_long:</span> option requires an argument -- <span class="string">&#x27;a&#x27;</span></span><br><span class="line">opt = ?</span><br><span class="line">optarg = (null)</span><br><span class="line">optind = <span class="number">2</span></span><br><span class="line">argv[optind - <span class="number">1</span>] = -a</span><br><span class="line">option_index = 0</span><br><span class="line">cashey<span class="variable">@ubuntu</span><span class="symbol">:~/Desktop/getopt</span><span class="variable">$ </span>./test_getopt_long --reqarg</span><br><span class="line">./<span class="symbol">test_getopt_long:</span> option <span class="string">&#x27;--reqarg&#x27;</span> requires an argument</span><br><span class="line">opt = ?</span><br><span class="line">optarg = (null)</span><br><span class="line">optind = <span class="number">2</span></span><br><span class="line">argv[optind - <span class="number">1</span>] = --reqarg</span><br></pre></td></tr></table></figure>
<p>最后说说<code>getopt_long_only</code>函数，它与getopt_long函数使用相同的参数表，在功能上基本一致，只是getopt_long只将–name当作长参数，但getopt_long_only会将–name和-name两种选项都当作长参数来匹配。在getopt_long在遇到-name时，会拆解成-n -a -m -e到optstring中进行匹配，而getopt_long_only只在-name不能在longopts中匹配时才将其拆解成-n -a -m -e这样的参数到optstring中进行匹配。</p>
]]></content>
      <tags>
        <tag>linux</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>go-cgo-oracle</title>
    <url>/2020/04/09/go-cgo-oracle/</url>
    <content><![CDATA[<h1 id="Linux-环境"><a href="#Linux-环境" class="headerlink" title="Linux 环境"></a>Linux 环境</h1><h2 id="安装-oracle-instantclient"><a href="#安装-oracle-instantclient" class="headerlink" title="安装 oracle-instantclient"></a>安装 oracle-instantclient</h2><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><ul>
<li><p><a href="https://www.oracle.com/database/technologies/instant-client/linux-x86-64-downloads.html">Oracle 官网</a> 下载 zip 包并解压</p>
<ul>
<li>instantclient-basic-linux.x64-12.2.0.1.0.zip</li>
<li>instantclient-basiclite-linux.x64-12.2.0.1.0.zip</li>
<li>instantclient-sdk-linux.x64-12.2.0.1.0.zip</li>
<li>instantclient-sqlplus-linux.x64-12.2.0.1.0.zip</li>
</ul>
</li>
<li><p><a href="https://github.com/bumpx/oracle-instantclient">https://github.com/bumpx/oracle-instantclient</a> 【推荐下载】</p>
</li>
</ul>
<a id="more"></a>

<h3 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">unzip -ojd /usr/<span class="built_in">local</span>  instantclient-basiclite-linux.x64-12.2.0.1.0.zip</span><br><span class="line">or </span><br><span class="line">unzip -ojd /usr/<span class="built_in">local</span>  instantclient-basic-linux.x64-12.2.0.1.0.zip</span><br><span class="line"></span><br><span class="line">ln -snf /usr/<span class="built_in">local</span>/instantclient_12_2/libclntsh.so.12.1 /usr/<span class="built_in">local</span>/instantclient_12_2/libclntsh.so</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开发使用</span></span><br><span class="line">unzip -ojd /usr/<span class="built_in">local</span>  instantclient-sdk-linux.x64-12.2.0.1.0.zip</span><br></pre></td></tr></table></figure>
<h3 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h3><h4 id="LD-LIBRARY-PATH"><a href="#LD-LIBRARY-PATH" class="headerlink" title="LD_LIBRARY_PATH"></a>LD_LIBRARY_PATH</h4><figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">export LD_LIBRARY_PATH=<span class="variable">$LD_LIBRARY_PATH</span><span class="symbol">:/usr/local/instantclient_12_2</span></span><br></pre></td></tr></table></figure>
<h4 id="oci8-pc"><a href="#oci8-pc" class="headerlink" title="oci8.pc"></a>oci8.pc</h4><blockquote>
<p>修改 pc 文件 (可以参考 github.com/mattn/go-oci8/README.MD)</p>
</blockquote>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="attribute">prefix</span>=/usr/local/instantclient_12_2</span><br><span class="line"><span class="attribute">includedir</span>=<span class="variable">$&#123;prefix&#125;</span>/sdk/include</span><br><span class="line"><span class="attribute">libdir</span>=<span class="variable">$&#123;prefix&#125;</span></span><br><span class="line"></span><br><span class="line">Name: oci8</span><br><span class="line">Description: Oracle Instant Client</span><br><span class="line">Version: 12.2</span><br><span class="line">Cflags: -I<span class="variable">$&#123;includedir&#125;</span></span><br><span class="line">Libs: -L<span class="variable">$&#123;libdir&#125;</span> -lclntsh</span><br></pre></td></tr></table></figure>
<ul>
<li>重新配置环境变量 PKG_CONFIG_PATH 目录，放入 oci8.pc<ul>
<li>export PKG_CONFIG_PATH=xxx</li>
</ul>
</li>
<li>放入系统路径， /usr/local/lib/pkgconfig/<ul>
<li>export PKG_CONFIG_PATH=$PKG_CONFIG_PATH:/usr/local/lib/pkgconfig</li>
</ul>
</li>
</ul>
<h4 id="检查开发环境"><a href="#检查开发环境" class="headerlink" title="检查开发环境"></a>检查开发环境</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜ pkg-config --cflags oci8</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出这个则正常</span></span><br><span class="line">-I/usr/<span class="built_in">local</span>/instantclient_12_2/sdk/include/  </span><br></pre></td></tr></table></figure>
<h1 id="windows-环境"><a href="#windows-环境" class="headerlink" title="windows 环境"></a>windows 环境</h1><h2 id="安装-oracle-instantclient-1"><a href="#安装-oracle-instantclient-1" class="headerlink" title="安装 oracle-instantclient"></a>安装 oracle-instantclient</h2><h3 id="下载-1"><a href="#下载-1" class="headerlink" title="下载"></a>下载</h3><ul>
<li><a href="https://www.oracle.com/database/technologies/instant-client/linux-x86-64-downloads.html">Oracle 官网</a> 下载 zip 包并解压<ul>
<li>instantclient-basiclite-windows.x64-12.2.0.1.0.zip</li>
<li>instantclient-basic-windows.x64-12.2.0.1.0_2.zip</li>
<li>instantclient-sdk-windows.x64-12.2.0.1.0.zip</li>
</ul>
</li>
</ul>
<h3 id="解压-1"><a href="#解压-1" class="headerlink" title="解压"></a>解压</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">到C盘</span><br><span class="line">解压 instantclient-basiclite-windows.x64-12.2.0.1.0.zip</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开发使用</span></span><br><span class="line">解压 instantclient-sdk-windows.x64-12.2.0.1.0.zip</span><br></pre></td></tr></table></figure>
<h3 id="设置-1"><a href="#设置-1" class="headerlink" title="设置"></a>设置</h3><h4 id="oracle-环境"><a href="#oracle-环境" class="headerlink" title="oracle 环境"></a>oracle 环境</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ORACLE_HOME = C:\instantclient_12_2</span><br><span class="line">TNS_ADMIN = %ORACLE_HOME%\ADMIN</span><br><span class="line">NLS_LANG = SIMPLIFIED CHINESE_CHINA.AL32UTF8</span><br><span class="line">or</span><br><span class="line">NLS_LANG = SIMPLIFIED CHINESE_CHINA.ZHS16GBK</span><br></pre></td></tr></table></figure>
<h2 id="安装-Mingw-w64"><a href="#安装-Mingw-w64" class="headerlink" title="安装 Mingw-w64"></a>安装 Mingw-w64</h2><p><a href="http://sourceforge.net/projects/mingw-w64/">http://sourceforge.net/projects/mingw-w64/</a></p>
<p>8.1.0 posix seh x86_64-8.1.0-release-posix-seh-rt_v6-rev0</p>
<p>直接下载解压即可，解压的目录 %MINGW64_HOME% ，将 %MINGW64_HOME%\bin 配置在环境变量 Path 中<br>然后命令行输入 gcc -v 打印</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gcc -v</span><br><span class="line"></span><br><span class="line">Using built-in specs.</span><br><span class="line">COLLECT_GCC=gcc</span><br><span class="line">COLLECT_LTO_WRAPPER=C:/mingw64/bin/../libexec/gcc/x86_64-w64-mingw32/8.1.0/lto-wrapper.exe</span><br><span class="line">Target: x86_64-w64-mingw32</span><br><span class="line">Configured with: ../../../src/gcc-8.1.0/configure --host=x86_64-w64-mingw32 --build=x86_64-w64-mingw32 --target=x86_64-w64-mingw32 --prefix=/mingw64 --with-sysroot=/c/mingw810/x86_64-810-posix-seh-rt_v6-rev0/mingw64 --enable-shared --enable-static --disable-multilib --enable-languages=c,c++,fortran,lto --enable-libstdcxx-time=yes --enable-threads=posix --enable-libgomp --enable-libatomic --enable-lto --enable-graphite --enable-checking=release --enable-fully-dynamic-string --enable-version-specific-runtime-libs --disable-libstdcxx-pch --disable-libstdcxx-debug --enable-bootstrap --disable-rpath --disable-win32-registry --disable-nls --disable-werror --disable-symvers --with-gnu-as --with-gnu-ld --with-arch=nocona --with-tune=core2 --with-libiconv --with-system-zlib --with-gmp=/c/mingw810/prerequisites/x86_64-w64-mingw32-static --with-mpfr=/c/mingw810/prerequisites/x86_64-w64-mingw32-static --with-mpc=/c/mingw810/prerequisites/x86_64-w64-mingw32-static --with-isl=/c/mingw810/prerequisites/x86_64-w64-mingw32-static --with-pkgversion=<span class="string">&#x27;x86_64-posix-seh-rev0, Built by MinGW-W64 project&#x27;</span> --with-bugurl=https://sourceforge.net/projects/mingw-w64 CFLAGS=<span class="string">&#x27;-O2 -pipe -fno-ident -I/c/mingw810/x86_64-810-posix-seh-rt_v6-rev0/mingw64/opt/include -I/c/mingw810/prerequisites/x86_64-zlib-static/include -I/c/mingw810/prerequisites/x86_64-w64-mingw32-static/include&#x27;</span> CXXFLAGS=<span class="string">&#x27;-O2 -pipe -fno-ident -I/c/mingw810/x86_64-810-posix-seh-rt_v6-rev0/mingw64/opt/include -I/c/mingw810/prerequisites/x86_64-zlib-static/include -I/c/mingw810/prerequisites/x86_64-w64-mingw32-static/include&#x27;</span> CPPFLAGS=<span class="string">&#x27; -I/c/mingw810/x86_64-810-posix-seh-rt_v6-rev0/mingw64/opt/include -I/c/mingw810/prerequisites/x86_64-zlib-static/include -I/c/mingw810/prerequisites/x86_64-w64-mingw32-static/include&#x27;</span> LDFLAGS=<span class="string">&#x27;-pipe -fno-ident -L/c/mingw810/x86_64-810-posix-seh-rt_v6-rev0/mingw64/opt/lib -L/c/mingw810/prerequisites/x86_64-zlib-static/lib -L/c/mingw810/prerequisites/x86_64-w64-mingw32-static/lib &#x27;</span></span><br><span class="line">Thread model: posix</span><br><span class="line">gcc version 8.1.0 (x86_64-posix-seh-rev0, Built by MinGW-W64 project)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="配置全局-make"><a href="#配置全局-make" class="headerlink" title="配置全局 make"></a>配置全局 make</h3><p>进入mingw64 的安装目录，新建文件 make.bat 内容为</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line"><span class="title">@echo</span> off</span><br><span class="line">C:\mingw<span class="number">64</span>\bin\mingw<span class="number">32</span>-make.exe <span class="variable">%1</span> <span class="variable">%2</span> <span class="variable">%3</span> <span class="variable">%4</span> <span class="variable">%5</span> <span class="variable">%6</span> <span class="variable">%7</span> <span class="variable">%8</span> <span class="variable">%9</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ make -v</span><br><span class="line"></span><br><span class="line">GNU Make 4.2.1</span><br><span class="line">Built <span class="keyword">for</span> x86_64-w64-mingw32</span><br><span class="line">Copyright (C) 1988-2016 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.</span><br></pre></td></tr></table></figure>
<h3 id="pkg-config"><a href="#pkg-config" class="headerlink" title="pkg-config"></a>pkg-config</h3><p>新建 C:\mingw64\lib\pkg-config\oci8.pc</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">prefix</span>=C:/instantclient_<span class="number">12</span>_<span class="number">2</span>/instantclient_<span class="number">12</span>_<span class="number">2</span></span><br><span class="line"><span class="attribute">exec_prefix</span>=<span class="variable">$&#123;prefix&#125;</span></span><br><span class="line"><span class="attribute">libdir</span>=<span class="variable">$&#123;exec_prefix&#125;</span></span><br><span class="line"><span class="attribute">includedir</span>=<span class="variable">$&#123;prefix&#125;</span>/sdk/include/</span><br><span class="line"></span><br><span class="line"><span class="attribute">Name</span>: oci<span class="number">8</span></span><br><span class="line"><span class="attribute">Description</span>: oci<span class="number">8</span> library</span><br><span class="line"><span class="attribute">Version</span>: <span class="number">12</span>.<span class="number">2</span></span><br><span class="line"><span class="attribute">Libs</span>: -L<span class="variable">$&#123;libdir&#125;</span> -loci</span><br><span class="line"><span class="attribute">Cflags</span>: -I<span class="variable">$&#123;includedir&#125;</span></span><br></pre></td></tr></table></figure>
<p>环境变量</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line">PKG_CONFIG_PATH = <span class="symbol">C:</span>\mingw64\<span class="class"><span class="keyword">lib</span>\<span class="title">pkg</span>-<span class="title">config</span></span></span><br></pre></td></tr></table></figure>
<p>安装 pkg-config.exe  </p>
<p><a href="https://pkg-config.freedesktop.org/releases/">https://pkg-config.freedesktop.org/releases/</a> </p>
<p><a href="https://stackoverflow.com/questions/1710922/how-to-install-pkg-config-in-windows">https://stackoverflow.com/questions/1710922/how-to-install-pkg-config-in-windows</a></p>
<p><a href="http://ftp.gnome.org/pub/gnome/binaries/win32/dependencies/">http://ftp.gnome.org/pub/gnome/binaries/win32/dependencies/</a></p>
<p>C:\mingw64\bin\pkg-config.exe</p>
<h3 id="检查开发环境-1"><a href="#检查开发环境-1" class="headerlink" title="检查开发环境"></a>检查开发环境</h3><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">pkg-config --cflags oci8</span><br><span class="line">-IC:<span class="regexp">/instantclient_12_2/</span>sdk<span class="regexp">/include/</span></span><br></pre></td></tr></table></figure>
<h1 id="示例代码-sql-go"><a href="#示例代码-sql-go" class="headerlink" title="示例代码 sql.go"></a>示例代码 sql.go</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat &gt;sql.go &lt;&lt;\EOF</span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    <span class="string">&quot;database/sql&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line"></span><br><span class="line">    _ <span class="string">&quot;github.com/mattn/go-oci8&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> len(os.Args) != 2 &#123;</span><br><span class="line">        log.Fatalln(os.Args[0] + <span class="string">&quot; user/password@host:port/sid&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    db, err := sql.Open(<span class="string">&quot;oci8&quot;</span>, os.Args[1])</span><br><span class="line">    <span class="keyword">if</span> err != nil &#123;</span><br><span class="line">        log.Fatalln(err)</span><br><span class="line">    &#125;</span><br><span class="line">    defer db.Close()</span><br><span class="line"></span><br><span class="line">    rows, err := db.Query(<span class="string">&quot;select user from dual&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != nil &#123;</span><br><span class="line">        log.Fatalln(err)</span><br><span class="line">    &#125;</span><br><span class="line">    defer rows.Close()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> rows.<span class="function"><span class="title">Next</span></span>() &#123;</span><br><span class="line">        var data string</span><br><span class="line">        rows.Scan(&amp;data)</span><br><span class="line">        fmt.Println(data)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err = rows.Err(); err != nil &#123;</span><br><span class="line">        log.Fatalln(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
<h2 id="database-sql"><a href="#database-sql" class="headerlink" title="database/sql"></a>database/sql</h2><p>参考 <a href="http://go-database-sql.org/">Go database/sql tutorial</a></p>
]]></content>
      <tags>
        <tag>go</tag>
        <tag>oracle</tag>
        <tag>cgo</tag>
        <tag>Mingw-w64</tag>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2015/03/27/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="http://hexo.io/">Hexo</a>! This is your very first post. Check <a href="http://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="http://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<a id="more"></a>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/deployment.html">Deployment</a></p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="http://music.163.com/outchain/player?type=2&id=28947001&auto=1&height=66"></iframe>
]]></content>
  </entry>
  <entry>
    <title>select的四大用法</title>
    <url>/2020/03/16/select%E7%9A%84%E5%9B%9B%E5%A4%A7%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<p><a href="https://tour.golang.org/concurrency/5">select</a> 跟 <a href="https://tour.golang.org/flowcontrol/9">switch</a> 有个共同特性就是都通过 case 的方式来处理，但是 select 跟 switch 处理的事情完全不同，也完全不相容。</p>
<h1 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h1><p>特性: </p>
<ul>
<li>1.各种类型及型别操作，接口 interface{} 型别判断 variable.(type)</li>
<li>2.会依照 case <code>顺序依序执行</code></li>
</ul>
<a id="more"></a>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    i <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">convert</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> t := i.(<span class="keyword">type</span>) &#123;</span><br><span class="line">    caseint:</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">&quot;i is interger&quot;</span>, t)</span><br><span class="line">    casestring:</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">&quot;i is string&quot;</span>, t)</span><br><span class="line">    casefloat64:</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">&quot;i is float64&quot;</span>, t)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">&quot;type not found&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    i = <span class="number">100</span></span><br><span class="line">    convert(i)</span><br><span class="line">    i = <span class="keyword">float64</span>(<span class="number">45.55</span>)</span><br><span class="line">    convert(i)</span><br><span class="line">    i = <span class="string">&quot;foo&quot;</span></span><br><span class="line">    convert(i)</span><br><span class="line">    convert(<span class="keyword">float32</span>(<span class="number">10.0</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行出来的结果如下:</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">i <span class="keyword">is</span> <span class="built_in">int</span>erger <span class="number">100</span></span><br><span class="line">i <span class="keyword">is</span> <span class="built_in">float</span>64 +<span class="number">4.555000e+001</span></span><br><span class="line">i <span class="keyword">is</span> <span class="built_in">string</span> foo</span><br><span class="line">type <span class="keyword">not</span> found</span><br></pre></td></tr></table></figure>
<p>而 select 的特性就不同了，只能接收 channel，否则会出错，而 default 会直接执行，所以<code>没有 default 的 select 就会遇到 blocking</code>，假设没有送 value 进去 Channel 就会造成 panic，底下拿几个实际例子来解说。</p>
<h1 id="select"><a href="#select" class="headerlink" title="select"></a>select</h1><h2 id="Random-Select"><a href="#Random-Select" class="headerlink" title="Random Select"></a>Random Select</h2><p>同一个 channel 在 select 会随机选取，底下看个例子:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span><span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    ch &lt;- <span class="number">1</span></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-ch:</span><br><span class="line">        fmt.Println(<span class="string">&quot;random 01&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> &lt;-ch:</span><br><span class="line">        fmt.Println(<span class="string">&quot;random 02&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行后会发现有时候拿到 random 01 有时候拿到 random 02，这就是 select 的特性之一，case 是随机选取，所以当 select 有两个 channel 以上时，如果同时对全部 channel 送资料，则会随机选取到不同的 Channel。而上面有提到另一个特性『假设没有送 value 进入 Channel 就会造成 panic』，拿上面例子来改:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-ch:</span><br><span class="line">        fmt.Println(<span class="string">&quot;random 01&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> &lt;-ch:</span><br><span class="line">        fmt.Println(<span class="string">&quot;random 02&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行后会发现变成 deadlock，造成 main 主程式爆炸，这时候可以直接用 default 方式解决此问题:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-ch:</span><br><span class="line">        fmt.Println(<span class="string">&quot;random 01&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> &lt;-ch:</span><br><span class="line">        fmt.Println(<span class="string">&quot;random 02&quot;</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;exit&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主程式 main 就不会因为读不到 channel value 造成整个程式 deadlock。</p>
<h2 id="Timeout-超时机制"><a href="#Timeout-超时机制" class="headerlink" title="Timeout 超时机制"></a>Timeout 超时机制</h2><p>用 select 读取 channle 时，一定会实作超过一定时间后就做其他事情，而不是一直 blocking 在 select 内。底下是简单的例子:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    timeout := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">        timeout &lt;- <span class="literal">true</span></span><br><span class="line">    &#125;()</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-ch:</span><br><span class="line">    <span class="keyword">case</span> &lt;-timeout:</span><br><span class="line">        fmt.Println(<span class="string">&quot;timeout 01&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>建立 timeout channel，让其他地方可以透过 trigger timeout channel 达到让 select 执行结束，也或者有另一个写法是透握 time.After 机制</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ch:</span><br><span class="line"><span class="keyword">case</span> &lt;-timeout:</span><br><span class="line">    fmt.Println(<span class="string">&quot;timeout 01&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(time.Second * <span class="number">1</span>):</span><br><span class="line">    fmt.Println(<span class="string">&quot;timeout 02&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以注意 time.After 是回传 chan time.Time，所以执行 select 超过一秒时，就会输出 timeout 02。</p>
<h2 id="检查-channel-是否已满"><a href="#检查-channel-是否已满" class="headerlink" title="检查 channel 是否已满"></a>检查 channel 是否已满</h2><p>直接来看例子比较快:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>)</span><br><span class="line">    ch &lt;- <span class="number">1</span></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> ch &lt;- <span class="number">2</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;channel value is&quot;</span>, &lt;-ch)</span><br><span class="line">        fmt.Println(<span class="string">&quot;channel value is&quot;</span>, &lt;-ch)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;channel blocking&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先宣告 buffer size 为 1 的 channel，先丢值把 channel 填满。这时候可以透过 select + default 方式来确保 channel 是否已满，上面例子会输出 channel blocking，我们再把程式改成底下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(chanint, <span class="number">2</span>)</span><br><span class="line">    ch &lt;- <span class="number">1</span></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> ch &lt;- <span class="number">2</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;channel value is&quot;</span>, &lt;-ch)</span><br><span class="line">        fmt.Println(<span class="string">&quot;channel value is&quot;</span>, &lt;-ch)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;channel blocking&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>把 buffer size 改为 2 后，就可以继续在塞 value 进去 channel 了，这边的 buffer channel 观念可以看之前的文章『用五分钟了解什么是 unbuffered vs buffered channel』[1]</p>
<h2 id="select-for-loop-用法"><a href="#select-for-loop-用法" class="headerlink" title="select for loop 用法"></a>select for loop 用法</h2><p>如果你有多个 channel 需要读取，而读取是不间断的，就必须使用 for + select 机制来实现，更详细的实作可以参考『15 分钟学习 Go 语言如何处理多个 Channel 通道』</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">close</span>(ch)</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    LOOP:</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">            fmt.Println(time.Now().Unix())</span><br><span class="line">            i++</span><br><span class="line"></span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> m := &lt;-ch:</span><br><span class="line">                <span class="built_in">println</span>(m)</span><br><span class="line">                <span class="keyword">break</span> LOOP</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    time.Sleep(time.Second * <span class="number">4</span>)</span><br><span class="line">    ch &lt;- <span class="string">&quot;stop&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面例子可以发现执行后如下:</p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line"><span class="number">1257894001</span></span><br><span class="line"><span class="number">1257894002</span></span><br><span class="line"><span class="number">1257894003</span></span><br><span class="line"><span class="number">1257894004</span></span><br><span class="line"><span class="number">1257894005</span></span><br><span class="line">stop</span><br></pre></td></tr></table></figure>
<p>其实把 default 拿掉也可以达到目的</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> m := &lt;-ch:</span><br><span class="line">    <span class="built_in">println</span>(m)</span><br><span class="line">    <span class="keyword">break</span> LOOP</span><br></pre></td></tr></table></figure>
<p>当没有值送进来时，就会一直停在 select 区段，所以其实没有 default 也是可以正常运作的，而要结束 for 或 select 都需要透过 break 来结束，但是要<code>在 select 区间直接结束掉 for 回圈，只能使用 break variable 来结束，这边是大家需要注意的地方</code>。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>[1]『用五分钟了解什么是 unbuffered vs buffered channel』: <a href="https://blog.wu-boy.com/2019/04/understand-unbuffered-vs-buffered-channel-in-five-minutes/">https://blog.wu-boy.com/2019/04/understand-unbuffered-vs-buffered-channel-in-five-minutes/</a></p>
<h1 id="Thinks"><a href="#Thinks" class="headerlink" title="Thinks"></a>Thinks</h1><blockquote>
<p>原文链接：<a href="https://blog.wu-boy.com/2019/11/four-tips-with-select-in-golang/">https://blog.wu-boy.com/2019/11/four-tips-with-select-in-golang/</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>go</tag>
        <tag>select</tag>
      </tags>
  </entry>
  <entry>
    <title>singleflight本地缓存实例</title>
    <url>/2020/03/15/singleflight%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98%E5%AE%9E%E4%BE%8B/</url>
    <content><![CDATA[<p>本地保存商户信息，模拟并发情况下缓存穿透情况，到 DB 获取 MCH 信息。</p>
<a id="more"></a>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;errors&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;github.com/golang/groupcache/singleflight&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">500</span>; i++ &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(n <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">			<span class="keyword">var</span> mchId = <span class="string">&quot;12345&quot;</span></span><br><span class="line">			<span class="keyword">var</span> mch, err = mchCache.GetMch(mchId)</span><br><span class="line">			fmt.Println(n, mch, err)</span><br><span class="line">			wg.Done()</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MchCache <span class="keyword">struct</span> &#123;</span><br><span class="line">	Mchs <span class="keyword">map</span>[<span class="keyword">string</span>]MchInfo</span><br><span class="line">	sync.RWMutex</span><br><span class="line">	g singleflight.Group</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MchInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">	ID   <span class="keyword">string</span></span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mchCache MchCache</span><br><span class="line"><span class="keyword">var</span> errMchNotFound = errors.New(<span class="string">&quot;mch not found in cache&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *MchCache)</span> <span class="title">GetMch</span><span class="params">(id <span class="keyword">string</span>)</span> <span class="params">(mch MchInfo, err error)</span></span> &#123;</span><br><span class="line">	mch, err = c.getMch(id)</span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	m, err := c.g.Do(id, <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line">		<span class="keyword">return</span> c.getMchFromDB(id)</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	mch = m.(MchInfo)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *MchCache)</span> <span class="title">getMch</span><span class="params">(id <span class="keyword">string</span>)</span> <span class="params">(mch MchInfo, err error)</span></span> &#123;</span><br><span class="line">	c.RLock()</span><br><span class="line">	<span class="keyword">defer</span> c.RUnlock()</span><br><span class="line">	<span class="keyword">if</span> c.Mchs == <span class="literal">nil</span> &#123;</span><br><span class="line">		c.Mchs = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]MchInfo)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> mch, ok := c.Mchs[id]; ok &#123;</span><br><span class="line">		<span class="keyword">return</span> mch, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> mch, errMchNotFound</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *MchCache)</span> <span class="title">SetMch</span><span class="params">(mch MchInfo)</span></span> &#123;</span><br><span class="line">	c.Lock()</span><br><span class="line">	<span class="keyword">defer</span> c.Unlock()</span><br><span class="line">	<span class="keyword">if</span> c.Mchs == <span class="literal">nil</span> &#123;</span><br><span class="line">		c.Mchs = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]MchInfo)</span><br><span class="line">	&#125;</span><br><span class="line">	c.Mchs[mch.ID] = mch</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *MchCache)</span> <span class="title">getMchFromDB</span><span class="params">(id <span class="keyword">string</span>)</span> <span class="params">(mch MchInfo, err error)</span></span> &#123;</span><br><span class="line">	mch = MchInfo&#123;</span><br><span class="line">		ID:   id,</span><br><span class="line">		Name: <span class="string">&quot;星巴克&quot;</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	c.SetMch(mch)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>cache</tag>
        <tag>go</tag>
        <tag>singleflight</tag>
      </tags>
  </entry>
  <entry>
    <title>在线ssl工具集</title>
    <url>/2019/09/29/ssltools/</url>
    <content><![CDATA[<p>最近遇到部署https网站，在iOS端访问正常，在Android端访问异常，检查发现是证书链补全导致，缺少中间证书。</p>
<a id="more"></a>

<h1 id="myssl-cn"><a href="#myssl-cn" class="headerlink" title="myssl.cn"></a>myssl.cn</h1><ul>
<li><a href="https://www.myssl.cn/tools/check-server-cert.html">SSL服务器证书安装检查器</a></li>
<li><a href="https://www.myssl.cn/tools/create-csr.html">CSR 在线生成</a></li>
<li><a href="https://www.myssl.cn/tools/downloadchain.html">获取证书信息 及 下载中间证书(可用于证书链修复)</a></li>
</ul>
<h1 id="myssl-com"><a href="#myssl-com" class="headerlink" title="myssl.com"></a>myssl.com</h1><ul>
<li><a href="https://myssl.com/chain_download.html">证书链下载／证书链修复</a></li>
<li><a href="https://myssl.com/ssl.html">SSL状态检测</a></li>
<li><a href="https://myssl.com/csr_create.html">CSR 在线生成</a></li>
<li><a href="https://myssl.com/cert_convert.html">证书格式转换</a></li>
</ul>
<h1 id="web-chacuo-net"><a href="#web-chacuo-net" class="headerlink" title="web.chacuo.net"></a>web.chacuo.net</h1><ul>
<li><a href="http://web.chacuo.net/netcsrdecoder">CSR请求证书文件信息</a></li>
</ul>
]]></content>
      <tags>
        <tag>ssl</tag>
        <tag>https</tag>
      </tags>
  </entry>
  <entry>
    <title>利用python发邮件</title>
    <url>/2016/01/19/%E5%88%A9%E7%94%A8python%E5%8F%91%E9%82%AE%E4%BB%B6/</url>
    <content><![CDATA[<p>在刚开始学习python的时候就听有的人说，用python发邮件简直太轻松了，随着学习的深入，今天学习了一下python的smtplib模块，果不其然，只需几行代码就可以轻松实现发邮件的功能。<br>在本例中，使用自己的163邮箱给qq邮箱发测试样例。</p>
<a id="more"></a>

<hr>
<p>一共需要四部即可</p>
<blockquote>
<ul>
<li>连接到服务器</li>
<li>登录</li>
<li>发出服务请求</li>
<li>退出</li>
</ul>
</blockquote>
<p>遵从这四步，首先一段简单的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding: utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> smtplib</span><br><span class="line"></span><br><span class="line">msg = <span class="string">&#x27;From: xxx@163.com\r\nTo: xxx@qq.com\r\nSubject: Test smtp by python\r\n\r\nJust for test&#x27;</span></span><br><span class="line">handle = smtplib.SMTP(<span class="string">&#x27;smtp.163.com&#x27;</span>, <span class="string">&#x27;25&#x27;</span>)          <span class="comment">#第一步</span></span><br><span class="line">handle.login(<span class="string">&#x27;xxx@163.com&#x27;</span>, <span class="string">&#x27;xxxxx&#x27;</span>)                 <span class="comment">#第二步  用户名和密码</span></span><br><span class="line">handle.sendmail(<span class="string">&#x27;xxx@163.com&#x27;</span>, <span class="string">&#x27;xxx@qq.com&#x27;</span>, msg)    <span class="comment">#第三步</span></span><br><span class="line">handle.quit()                                        <span class="comment">#第四步</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;send successfully&#x27;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li><code>sendmail()</code>的所有参数要遵循RFC 2822，即电子邮件的地址必须要有正确的格式，消息体要有正确的前导头，前导头后是两个回车和换行(<code>\r\n</code>)对</li>
<li>SMTP通讯时，只要一个端口<code>25</code></li>
</ul>
</blockquote>
<hr>
<p>以上很简单的就实现了利用python自带的<code>smtplib</code>模块实现了发送邮件的功能，但是在现实发邮件中，肯定比这样的要复杂。这时需要另一个模块<code>email</code>，<code>email</code>负责构造邮件，<code>smtplib</code>负责发送邮件。</p>
<p>构造一个邮件对象就是一个<code>Messag</code>对象，如果构造一个<code>MIMEText</code>对象，就表示一个文本邮件对象，如果构造一个<code>MIMEImage</code>对象，就表示一个作为附件的图片，要把多个对象组合起来，就用<code>MIMEMultipart</code>对象，而<code>MIMEBase</code>可以表示任何对象。<br>一个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> email <span class="keyword">import</span> encoders</span><br><span class="line"><span class="keyword">from</span> email.header <span class="keyword">import</span> Header</span><br><span class="line"><span class="keyword">from</span> email.mime.text <span class="keyword">import</span> MIMEText</span><br><span class="line"><span class="keyword">from</span> email.utils <span class="keyword">import</span> parseaddr, formataddr</span><br><span class="line"><span class="keyword">import</span> smtplib</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_format_addr</span>(<span class="params">s</span>):</span></span><br><span class="line">    name, addr = parseaddr(s)</span><br><span class="line">    <span class="keyword">return</span> formataddr(( \</span><br><span class="line">        Header(name, <span class="string">&#x27;utf-8&#x27;</span>).encode(), \</span><br><span class="line">        addr.encode(<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">if</span> <span class="built_in">isinstance</span>(addr, unicode) <span class="keyword">else</span> addr))</span><br><span class="line"></span><br><span class="line">from_addr = raw_input(<span class="string">&#x27;From: &#x27;</span>)</span><br><span class="line">password = raw_input(<span class="string">&#x27;Password: &#x27;</span>)</span><br><span class="line">to_addr = raw_input(<span class="string">&#x27;To: &#x27;</span>)</span><br><span class="line">smtp_server = raw_input(<span class="string">&#x27;SMTP server: &#x27;</span>)</span><br><span class="line"></span><br><span class="line">msg = MIMEText(<span class="string">&#x27;hello, send by Python...&#x27;</span>, <span class="string">&#x27;plain&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">msg[<span class="string">&#x27;From&#x27;</span>] = _format_addr(<span class="string">u&#x27;Python爱好者 &lt;%s&gt;&#x27;</span> % from_addr)</span><br><span class="line">msg[<span class="string">&#x27;To&#x27;</span>] = _format_addr(<span class="string">u&#x27;管理员 &lt;%s&gt;&#x27;</span> % to_addr)</span><br><span class="line">msg[<span class="string">&#x27;Subject&#x27;</span>] = Header(<span class="string">u&#x27;来自SMTP的问候……&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>).encode()</span><br><span class="line"></span><br><span class="line">server = smtplib.SMTP(smtp_server, <span class="number">25</span>)</span><br><span class="line">server.set_debuglevel(<span class="number">1</span>)</span><br><span class="line">server.login(from_addr, password)</span><br><span class="line">server.sendmail(from_addr, [to_addr], msg.as_string())</span><br><span class="line">server.quit()</span><br></pre></td></tr></table></figure>
<p>编写了一个函数<code>_format_addr()</code>来格式化一个邮件地址。注意不能简单地传入<code>name &lt;addr@example.com&gt;</code>，因为包含中文，所以需要使用<code>Header</code>对象进行编码。</p>
<hr>
<p>若需要添加附件时，可以构造一个<code>MIMEMultipart</code>对象代表邮件本身，然后往里面加上一个<code>MIMEText</code>作为邮件正文，再继续往里面加上表示附件的<code>MIMEBase</code>对象即可。</p>
<blockquote>
<p>原文出处： <a href="http://www.yehbeats.com/2015/03/31/python-smtp1/">利用python发邮件（一）</a><br>原文出处： <a href="http://www.yehbeats.com/2015/04/06/python-smtp2/">利用python发邮件（二）</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>在nginx proxy_pass中禁用IPv6</title>
    <url>/2019/10/22/%E5%9C%A8nginx%20proxy-pass%E4%B8%AD%E7%A6%81%E7%94%A8IPv6/</url>
    <content><![CDATA[<p>最近在生产服务上遇到 nginx 正向代理连接失败的问题。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">2019/10/22 15<span class="selector-pseudo">:25</span><span class="selector-pseudo">:21</span> <span class="selector-attr">[error]</span> 1930<span class="selector-id">#0</span>: *1482670 <span class="selector-tag">connect</span>() <span class="selector-tag">to</span> <span class="selector-attr">[AAAA:BBBB:C:DDD:E:F:GGG:HHH]</span><span class="selector-pseudo">:443</span> <span class="selector-tag">failed</span> (101: <span class="selector-tag">Network</span> <span class="selector-tag">is</span> <span class="selector-tag">unreachable</span>) <span class="selector-tag">while</span> <span class="selector-tag">connecting</span> <span class="selector-tag">to</span> <span class="selector-tag">upstream</span>, <span class="selector-tag">client</span>: <span class="selector-tag">AA</span><span class="selector-class">.BB</span><span class="selector-class">.CC</span><span class="selector-class">.DD</span>, <span class="selector-tag">server</span>: <span class="selector-tag">example</span><span class="selector-class">.com</span>, <span class="selector-tag">request</span>: &quot;<span class="selector-tag">GET</span> /<span class="selector-tag">download</span>/<span class="selector-tag">file</span> <span class="selector-tag">HTTP</span>/1.0&quot;, <span class="selector-tag">upstream</span>: &quot;<span class="selector-tag">https</span>://<span class="selector-attr">[AAAA:BBBB:C:DDD:E:F:GGG:HHH]</span><span class="selector-pseudo">:443</span>/<span class="selector-tag">download</span>/<span class="selector-tag">file</span>&quot;, <span class="selector-tag">host</span>: &quot;<span class="selector-tag">example</span><span class="selector-class">.com</span>&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>分析错误日志，应答是nginx尝试连接目标的 IPv6 地址端口时失败，错误<code>101: Network is unreachable</code></p>
<p>服务器没有IPv6地址，那就禁用nginx的IPv6解析</p>
<p>禁用IPv6很简单</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">resolver</span> <span class="number">8.8.8.8</span> ipv<span class="number">6</span>=<span class="literal">off</span>;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>nginx</tag>
        <tag>IPv6</tag>
      </tags>
  </entry>
  <entry>
    <title>服务优雅重启及热更新</title>
    <url>/2020/03/16/%E6%9C%8D%E5%8A%A1%E4%BC%98%E9%9B%85%E9%87%8D%E5%90%AF%E5%8F%8A%E7%83%AD%E6%9B%B4%E6%96%B0/</url>
    <content><![CDATA[<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">https:<span class="regexp">//</span>segmentfault.com<span class="regexp">/a/</span><span class="number">1190000013757098</span></span><br><span class="line">https:<span class="regexp">//</span>studygolang.com<span class="regexp">/articles/</span><span class="number">27226</span></span><br></pre></td></tr></table></figure>
<h1 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h1><ul>
<li>不关闭现有连接（正在运行中的程序）</li>
<li>新的进程启动并替代旧进程</li>
<li>新的进程接管新的连接</li>
<li>连接要随时响应用户的请求，当用户仍在请求旧进程时要保持连接，新用户应请求新进程，不可以出现拒绝请求的情况</li>
</ul>
<h1 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h1><ul>
<li>1、替换可执行文件或修改配置文件</li>
<li>2、发送信号量 SIGHUP</li>
<li>3、拒绝新连接请求旧进程，但要保证已有连接正常</li>
<li>4、启动新的子进程</li>
<li>5、新的子进程开始 Accet</li>
<li>6、系统将新的请求转交新的子进程</li>
<li>7、旧进程处理完所有旧连接后正常结束</li>
</ul>
<blockquote>
<p>以下内容引用</p>
</blockquote>
<a id="more"></a>

<h1 id="golang-hotfix热更新详解"><a href="#golang-hotfix热更新详解" class="headerlink" title="golang hotfix热更新详解"></a><a href="https://mojotv.cn/2018/12/26/golang-hot-restart">golang hotfix热更新详解</a></h1><h2 id="什么是热更新"><a href="#什么是热更新" class="headerlink" title="什么是热更新"></a>什么是热更新</h2><p>网络上有这么一个例子来形容热更新，我觉得很形象很贴切：</p>
<blockquote>
<p>一架行驶在高速上的大卡车，行驶过程中突然遭遇爆胎，热更新则是要求在不停车的情况下将车胎修补好，且补胎过程中卡车需要保持正常行驶.</p>
</blockquote>
<p>软件的热更新就是指在保持系统正常运行的情况下对系统进行更新升级.常见的情况有：系统服务升级、修复现有逻辑、服务配置更新等.</p>
<h2 id="热更新原理"><a href="#热更新原理" class="headerlink" title="热更新原理"></a>热更新原理</h2><p>先来看下Nginx热更新是如何做的？</p>
<p>Nginx支持运行中接收信号，方便开发者控制进程.</p>
<ul>
<li>1）首先备份原有的Nginx二进制文件，并用新编译好的Nginx二进制文件替换旧的</li>
<li>2）然后向master进程发送<code>USR2</code>信号.此时Nginx进程会启动一个新版本Nginx，该新版本Nginx进程会发起一个新的master进程与work进程.即此时会有两个Nginx实例在运行，一起处理新来的请求.</li>
<li>3）再向原master进程发送<code>WINCH</code>信号，它会逐渐关闭相关work进程，此时原master进程仍保持监听新请求但不会发送至其下work进程，而是交给新的work进程</li>
<li>4）最后等到所有原work进程全部关闭，向原master进程发送<code>QUIT</code>信号，终止原master进程，至此，完成Nginx热升级.</li>
</ul>
<blockquote>
<p>注：在*nix系统中，信号（Signal）是一种进程间通信机制，它给应用程序提供一种异步的软件中断，使应用程序有机会接受其他程序或终端发送的命令(即信号).</p>
</blockquote>
<p>同样地，golang热更新也可以采取类似的处理.如上篇所述，都是利用用户自定义信号USR2.</p>
<blockquote>
<p>注：Plugin包方式的golang热更新本文暂不讨论.</p>
</blockquote>
<h2 id="热更新实现"><a href="#热更新实现" class="headerlink" title="热更新实现"></a>热更新实现</h2><p>golang热更新可以细分为服务热『更新』（即热升级，类比Nginx的restart命令）与配置文件热更新（类比Nginx的reload命令）.接下来从实现细节处依次讨论.</p>
<h3 id="服务热更新"><a href="#服务热更新" class="headerlink" title="服务热更新"></a>服务热更新</h3><p>大致流程如下：</p>
<ul>
<li>1）golang服务进程运行时监听USR2信号</li>
<li>2）进程收到USR2信号后，fork子进程（启动新版本服务），并将当前socket句柄等进程环境交给它</li>
<li>3）新进程开始监听socket请求</li>
<li>4）等待旧服务连接停止</li>
</ul>
<p>主要代码示例如下：<br>监听<code>USR2</code>信号</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *app)</span> <span class="title">signalHandler</span><span class="params">(wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal, <span class="number">10</span>)</span><br><span class="line">    signal.Notify(ch, syscall.SIGINT, syscall.SIGTERM, syscall.SIGUSR2)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        sig := &lt;-ch</span><br><span class="line">        <span class="keyword">switch</span> sig &#123;</span><br><span class="line">        <span class="keyword">case</span> syscall.SIGINT, syscall.SIGTERM:</span><br><span class="line">            <span class="comment">// 确保接收到INT/TERM信号时可以触发golang标准的进程终止行为</span></span><br><span class="line">            signal.Stop(ch)</span><br><span class="line">            a.term(wg)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">case</span> syscall.SIGUSR2:</span><br><span class="line">            err := a.preStartProcess()</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                a.errors &lt;- err</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 发起新进程</span></span><br><span class="line">            <span class="keyword">if</span> _, err := a.net.StartProcess(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                a.errors &lt;- err</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复制当前进程socket连接，发起新进程</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">execSpec := &amp;syscall.ProcAttr&#123;</span><br><span class="line">       Env: os.Environ(),</span><br><span class="line">       Files: []<span class="keyword">uintptr</span>&#123;</span><br><span class="line">           os.Stdin.Fd(), </span><br><span class="line">           os.Stdout.Fd(), </span><br><span class="line">           os.Stderr.Fd()&#125;,</span><br><span class="line">   &#125;</span><br><span class="line">   fork, err := syscall.ForkExec(os.Args[<span class="number">0</span>], os.Args, execSpec)</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure>
<p>详细源码可见：<a href="https://scalingo.com/blog/graceful-server-restart-with-go.html">https://scalingo.com/articles…</a></p>
<p>以上仅为代码示例，目前已经成熟的开源实现主要有：endless和facebook的grace，原理基本类似，fork一个子进程，子进程监听原有父进程socket端口，父进程优雅退出.</p>
<p>在实际的生产环境中推荐使用以上开源库，关于热更新开源库的使用非常方便，下面是facebook的grace库的例子：<br>引入<code>github.com/facebookgo/grace/gracehttp</code>包</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    app := gin.New()<span class="comment">// 项目中时候的是gin框架</span></span><br><span class="line">    router.Route(app)</span><br><span class="line">    <span class="keyword">var</span> server *http.Server</span><br><span class="line">    server = &amp;http.Server&#123;</span><br><span class="line">        Addr:    <span class="string">&quot;:8080&quot;</span>,</span><br><span class="line">        Handler: app,</span><br><span class="line">    &#125;</span><br><span class="line">    gracehttp.Serve(server)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>利用<code>go build</code>命令编译，生成服务的可执行文件.<br>然后再用shell封装一下服务命令，生成restat.sh命令文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line">ps aux | grep wingo</span><br><span class="line">count=`ps -ef | grep <span class="string">&quot;wingo&quot;</span> | grep -v <span class="string">&quot;grep&quot;</span> | wc -l`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ 0 == <span class="variable">$count</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Wingo starting...&quot;</span></span><br><span class="line">    sudo ./wingo &amp;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Wingo started&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Wingo Restarting...&quot;</span></span><br><span class="line">    sudo <span class="built_in">kill</span> -USR2 $(ps -ef | grep <span class="string">&quot;wingo&quot;</span> | grep -v grep | awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span>)</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Wingo Restarted&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">sleep 1</span><br><span class="line"></span><br><span class="line">ps aux | grep wingo</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：其中wingo为服务的二进制名称.</p>
</blockquote>
<p>于是，便可通过执行./restart.sh命令，达到对服务的热升级目的.</p>
<h3 id="配置文件热更新"><a href="#配置文件热更新" class="headerlink" title="配置文件热更新"></a>配置文件热更新</h3><p>配置文件热更新是指在不停止服务的情况下，重新加载服务所有配置文件.<br>与3.1服务热升级原理一样，利用用户自定义信号:<code>USR1</code>，即可实现服务的配置文件热更新.</p>
<ul>
<li>1）服务监听USR1信号</li>
<li>2）服务接收到USR1信号后，停止接受新的连接，等待当前连接停止，重新载入配置文件，重启服务器，从而实现相对平滑的不停服的更改.</li>
</ul>
<p>主要代码实现：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// LoadAllConf 调用加载配置文件函数</span></span><br><span class="line"><span class="comment">// load为具体加载配置文件方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LoadAllConf</span><span class="params">(load <span class="keyword">func</span>(<span class="keyword">bool</span>)</span>)</span> &#123;</span><br><span class="line">    load(<span class="literal">true</span>)</span><br><span class="line">    listenSIGUSR1(load)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// listenSIGUSR1 监听SIGUSR1信号</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">listenSIGUSR1</span><span class="params">(f <span class="keyword">func</span>(<span class="keyword">bool</span>)</span>)</span> &#123;</span><br><span class="line">    s := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal, <span class="number">1</span>)</span><br><span class="line">    signal.Notify(s, syscall.SIGUSR1)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            &lt;-s</span><br><span class="line">            f(<span class="literal">false</span>)</span><br><span class="line">            log.Println(<span class="string">&quot;Reloaded&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>详细源码可见：<a href="https://www.openmymind.net/golang-Hot-Configuration-Reload/">https://www.openmymind.net/Go…</a></p>
<p>利用go build命令编译，生成服务的可执行文件.<br>然后再用shell封装一下配置重载命令，生成reload.sh命令文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line">ps aux | grep wingo</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Wingo Reloading...&quot;</span></span><br><span class="line">sudo <span class="built_in">kill</span> -USR1 $(ps -ef | grep <span class="string">&quot;wingo&quot;</span> | grep -v grep | awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span>)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Wingo Reloaded&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">sleep 1</span><br><span class="line"></span><br><span class="line">ps aux | grep wingo</span><br></pre></td></tr></table></figure>
<p>于是，便可通过执行./reload.sh命令，达到对服务的配置文件热升级目的.</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要描述了golang服务热升级与配置文件热更新原理与主要代码实现，本质上也不是什么新内容，如果之前读过《Unix环境高级编程》，就会觉得很亲切.底层原理基本上是利用了信号这个软件中断机制，在运行中改变常驻进程的行为.</p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p><a href="https://scalingo.com/articles/2014/12/19/graceful-server-restart-with-go.html">https://scalingo.com/articles…</a></p>
<p><a href="http://kuangchanglang.com/golang/2017/04/27/golang-graceful-restart#%E7%BB%86%E8%8A%82">http://kuangchanglang.com/gol…</a></p>
<p><a href="https://blog.csdn.net/black_OX/article/details/77869479">https://blog.csdn.net/black_O…</a></p>
<p><a href="https://www.openmymind.net/golang-Hot-Configuration-Reload/">https://www.openmymind.net/Go…</a></p>
<p><a href="https://blog.csdn.net/qq_15437667/article/details/83796838">https://blog.csdn.net/qq_1543…</a></p>
<p><a href="https://wrfly.kfd.me/posts/%E7%83%AD%E5%8D%87%E7%BA%A7/">https://wrfly.kfd.me/posts/%E…</a></p>
]]></content>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>源码阅读——十个C开源项目</title>
    <url>/2016/01/19/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E2%80%94%E2%80%94%E5%8D%81%E4%B8%AAC%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<h3 id="1-Webbench"><a href="#1-Webbench" class="headerlink" title="1. Webbench"></a>1. Webbench</h3><p>Webbench是一个在linux下使用的非常简单的网站压测工具。它使用fork()模拟多个客户端同时访问我们设定的URL，测试网站在压力下工作的性能，最多可以模拟3万个并发连接去测试网站的负载能力。Webbench使用C语言编写, 代码实在太简洁，源码加起来不到600行。下载链接：<a href="http://home.tiscali.cz/~cz210552/webbench.html">http://home.tiscali.cz/~cz210552/webbench.html</a></p>
<a id="more"></a>

<h3 id="2-CMockery"><a href="#2-CMockery" class="headerlink" title="2. CMockery"></a>2. CMockery</h3><p>cmockery是google发布的用于C单元测试的一个轻量级的框架。它很小巧，对其他开源包没有依赖，对被测试代码侵入性小。cmockery的源代码行数不到3K，你阅读一下will_return和mock的源代码就一目了然了。</p>
<p>主要特点：</p>
<ol>
<li>免费且开源，google提供技术支持；</li>
<li>轻量级的框架，使测试更加快速简单；</li>
<li>避免使用复杂的编译器特性，对老版本的编译器来讲，兼容性好;</li>
<li>并不强制要求待测代码必须依赖C99标准，这一特性对许多嵌入式系统的开发很有用</li>
</ol>
<p>下载链接：<a href="http://code.google.com/p/cmockery/downloads/list">http://code.google.com/p/cmockery/downloads/list</a></p>
<h3 id="3-Libev"><a href="#3-Libev" class="headerlink" title="3. Libev"></a>3. Libev</h3><p>libev是一个开源的事件驱动库，基于epoll，kqueue等OS提供的基础设施。其以高效出名，它可以将IO事件，定时器，和信号统一起来，统一放在事件处理这一套框架下处理。基于Reactor模式，效率较高，并且代码精简（4.15版本8000多行），是学习事件驱动编程的很好的资源。<a href="undefined">下载链接：</a><a href="http://software.schmorp.de/pkg/libev.html">http://software.schmorp.de/pkg/libev.html</a></p>
<h3 id="4-Memcached"><a href="#4-Memcached" class="headerlink" title="4. Memcached"></a>4. Memcached</h3><p>Memcached 是一个高性能的分布式内存对象缓存系统，用于动态Web应用以减轻数据库负载。它通过在内存中缓存数据和对象来减少读取数据库的次数，从而提供动态数据库驱动网站的速度。Memcached 基于一个存储键/值对的 hashmap。Memcached-1.4.7的代码量还是可以接受的，只有10K行左右。下载地址：<a href="http://memcached.org/">http://memcached.org/</a></p>
<h3 id="5-Lua"><a href="#5-Lua" class="headerlink" title="5. Lua"></a>5. Lua</h3><p>Lua很棒，Lua是巴西人发明的，这些都令我不爽，但是还不至于脸红，最多眼红。</p>
<p>让我脸红的是Lua的源代码，百分之一百的ANSI C，一点都不掺杂。在任何支持ANSI C编译器的平台上都可以轻松编译通过。我试过，真是一点废话都没有。Lua的代码数量足够小，5.1.4仅仅1.5W行，去掉空白行和注释估计能到1W行。下载地址：<a href="http://www.lua.org/">http://www.lua.org/</a></p>
<h3 id="6-SQLite"><a href="#6-SQLite" class="headerlink" title="6. SQLite"></a>6. SQLite</h3><p>SQLite是一个开源的嵌入式关系数据库，实现自包容、零配置、支持事务的SQL数据库引擎。 其特点是高度便携、使用方便、结构紧凑、高效、可靠。足够小，大致3万行C代码，250K。 下载地址：<a href="http://www.sqlite.org/">http://www.sqlite.org/</a> 。</p>
<h3 id="7-Redis"><a href="#7-Redis" class="headerlink" title="7. Redis"></a>7. Redis</h3><p>Redis是一个用ANSI C 编写的开源数据结构服务器。Redis的代码非常容易读懂，代码写的很整洁，并且代码量相对较小（4.5w行，其实也不是很小）。大部分都是单线程的，几乎不依赖其它库。下载地址：<a href="http://redis.io/">redis.io/</a></p>
<h3 id="8-Nginx"><a href="#8-Nginx" class="headerlink" title="8. Nginx"></a>8. Nginx</h3><p>Nginx(“engine x”) 是一个高性能的 HTTP 和反向代理服务器，也是一个 IMAP/POP3/SMTP 代理服务器 。Nginx 是由 Igor Sysoev 为俄罗斯访问量第二的Rambler.ru站点开发的，它已经在该站点运行超过四年多了。Igor 将源代码以类BSD许可证的形式发布。自Nginx 发布四年来，Nginx 已经因为它的稳定性、丰富的功能集、 示例配置文件和低系统资源的消耗而闻名了。</p>
<p>nginx的优秀除了体现在程序结构以及代码风格上，nginx的源码组织也同样简洁明了，目录结构层次结构清晰，值得我们去学习。下载地址：<a href="http://nginx.org/en/download.html">http://nginx.org/en/download.html</a>。</p>
<h3 id="9-UNIXv6"><a href="#9-UNIXv6" class="headerlink" title="9. UNIXv6"></a>9. UNIXv6</h3><p>UNIX V6 的内核源代码包括设备驱动程序在内 约有1 万行，这个数量的源代码，初学者是能够充分理解的。有一种说法是一个人所能理解的代码量上限为1 万行，UNIX V6的内核源代码从数量上看正好在这个范围之内。看到这里，大家是不是也有“如果只有1万行的话没准儿我也能学会”的想法呢？</p>
<p>另一方面，最近的操作系统，例如Linux 最新版的内核源代码据说超过了1000 万行。就算不是初学者，想完全理解全部代码基本上也是不可能的。下载地址：<a href="http://minnie.tuhs.org/cgi-bin/utree.pl?file=V6">http://minnie.tuhs.org/cgi-bin/utree.pl?file=V6</a></p>
<h3 id="10-NETBSD"><a href="#10-NETBSD" class="headerlink" title="10. NETBSD"></a>10. NETBSD</h3><p>NetBSD是一个免费的，具有高度移植性的 UNIX-like 操作系统，是现行可移植平台最多的操作系统，可以在许多平台上执行，从 64bit alpha 服务器到手持设备和嵌入式设备。NetBSD计划的口号是：”Of course it runs NetBSD”。它设计简洁，代码规范，拥有众多先进特性，使得它在业界和学术界广受好评。由于简洁的设计和先进的特征，使得它在生产和研究方面，都有卓越的表现，而且它也有受使用者支持的完整的源代码。许多程序都可以很容易地通过NetBSD Packages Collection获得。下载地址：<a href="http://www.netbsd.org/">http://www.netbsd.org/</a></p>
<blockquote>
<p>原文出处： <a href="http://my.oschina.net/zhoukuo/blog/335788?fromerr=yIHVJocN">平凡之路的博客</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>Source</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>微信支付踩坑</title>
    <url>/2020/01/31/%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%E8%B8%A9%E5%9D%91/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>编译Gargoyle</title>
    <url>/2015/12/25/%E7%BC%96%E8%AF%91Gargoyle/</url>
    <content><![CDATA[<p>make custom<br>make FULL_BUILD=true custom<br>cd custom-src &amp;&amp; make menuconfig &amp;&amp; make V=99</p>
<blockquote>
<p>custom-src/package/kernel/mac80211/files/lib/wifi/mac80211.sh</p>
</blockquote>
<p>option disabled 1改成0，默认开启wifi。<br>option disabled 0下添加<br>option htmode HT40+<br>option channel 1<br>option country CN<br>option noscan 1<br>option txpower 17</p>
<a id="more"></a>

<p><a href="http://blog.chinaunix.net/uid-25631578-id-4009228.html">http://blog.chinaunix.net/uid-25631578-id-4009228.html</a></p>
<pre><code>    option ssid &#39;Just-I&#39;
    option encryption &#39;psk2&#39;
    option key &#39;ubin.top&#39;</code></pre>
<p>编译OpenWrt之前 编辑 .config文件 搜索 “CONFIG_ATH_USER_REGD” 字符串<br>搜索到后把前面的 “#” 删掉 改成 CONFIG_ATH_USER_REGD=y<br>然后在去编译吧<br>编译好并刷机后，手动吧国家code代码改成CN 然后保存重启，就能看到13信道了，当然你也可以编译前设置国家code为CN，具体方法找度娘吧。<br>kmod-ath </p>
<p>以Atheros 芯片路由器为例:<br>编译的时候make menuconfig<br>进入：Kernel Modules - Wireless Drivers - Kmod-ath - Force Atheros drivers to respect the user’s regdomain settings. 选上。<br>保存设置，编译。<br>刷固件。<br>Luci中国家选择中国并保存（Save and Apply）<br>这样就可以使用1-13频道了</p>
<blockquote>
<p>custom-src/tools/firmware-utils/src/mktplinkfw.c<br>custom-src/target/linux/ar71xx/image/Makefile<br>custom-src/package/base-files/files/etc/config/network<br>custom-src/package/base-files/files/etc/config/system</p>
</blockquote>
<p>config system<br>        option hostname Just-I<br>        option timezone CST-8<br>        option zonename Asia/Shanghai</p>
<blockquote>
<p>custom-src/package/base-files/files/lib/functions/uci-defaults.sh</p>
</blockquote>
<blockquote>
<p>custom-src/.config</p>
</blockquote>
<blockquote>
<p>custom-src/package/gargoyle/files/etc/config/gargoyle<br>package/gargoyle/files/etc/config/gargoyle<br>option theme        ‘Theme by matei’</p>
</blockquote>
<p>个性化编译openwrt（编译前更改lan.ipaddr,ssid,timezone,root密码）</p>
<p>barrier_breaker_base<br><a href="http://downloads.openwrt.org/barrier_breaker/14.07/ar71xx/generic/packages/base">http://downloads.openwrt.org/barrier_breaker/14.07/ar71xx/generic/packages/base</a> 预置<br>barrier_breaker_management<br><a href="http://downloads.openwrt.org/barrier_breaker/14.07/ar71xx/generic/packages/management">http://downloads.openwrt.org/barrier_breaker/14.07/ar71xx/generic/packages/management</a>   预置<br>barrier_breaker_packages<br><a href="http://downloads.openwrt.org/barrier_breaker/14.07/ar71xx/generic/packages/packages">http://downloads.openwrt.org/barrier_breaker/14.07/ar71xx/generic/packages/packages</a> 预置<br>barrier_breaker_routing<br><a href="http://downloads.openwrt.org/barrier_breaker/14.07/ar71xx/generic/packages/routing">http://downloads.openwrt.org/barrier_breaker/14.07/ar71xx/generic/packages/routing</a>  预置<br>barrier_breaker_telephony<br><a href="http://downloads.openwrt.org/barrier_breaker/14.07/ar71xx/generic/packages/telephony">http://downloads.openwrt.org/barrier_breaker/14.07/ar71xx/generic/packages/telephony</a>    预置<br>gargoyle<br><a href="http://www.gargoyle-router.com/packages/gargoyle-1.8.1/ar71xx/default">http://www.gargoyle-router.com/packages/gargoyle-1.8.1/ar71xx/default</a>   预置</p>
]]></content>
      <tags>
        <tag>Gargoyle</tag>
        <tag>OpemWrt</tag>
      </tags>
  </entry>
  <entry>
    <title>系统上线</title>
    <url>/2015/12/13/%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%BA%BF/</url>
    <content><![CDATA[<h2 id="系统上线，通宵"><a href="#系统上线，通宵" class="headerlink" title="系统上线，通宵"></a>系统上线，通宵</h2><p>晚上4个系统要上线，通宵的节奏，预祝一切顺利！！！</p>
]]></content>
  </entry>
  <entry>
    <title>自动检测SOCKET链接断开</title>
    <url>/2016/01/20/%E8%87%AA%E5%8A%A8%E6%A3%80%E6%B5%8BSOCKET%E9%93%BE%E6%8E%A5%E6%96%AD%E5%BC%80/</url>
    <content><![CDATA[<blockquote>
<p>有些网络应用在网线断开后重新连上的情况下 tcp socket 连接保持 ESTABLISH 状态不变</p>
</blockquote>
<a id="more"></a>

<ul>
<li>1.假如应用程式不使用<code>tcp</code>的<code>keepalive</code>，在网线断开之后，以前建立的<code>socket</code>链接仍然会保持在<code>ESTABLISH</code>状态不会改变。实际上 <code>tcp</code>协议对这部分是有所处理的，需要服务端程式，在配置<code>socket</code>属性时，使用<code>keepalive option</code>，一 旦有此配置，这些长时间无数据的链接会根据<code>tcp</code>的<code>keepalive</code>内核属性，在<blockquote>
<p>(tcp_keepalive_time (tcp_keepalive_probes * tcp_keepalive_intvl))</p>
</blockquote>
</li>
</ul>
<p>所对应的时间（单位为秒）之后，断开这些链接。</p>
<p>关于<code>keep alive</code>,无论windows,还是linux,keepalive就三个参数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sk-&gt;keepalive_probes <span class="comment">//探测次数</span></span><br><span class="line">sk-&gt;keepalive_time   <span class="comment">//探测的超时</span></span><br><span class="line">sk-&gt;keepalive_intvl  <span class="comment">//探测间隔</span></span><br></pre></td></tr></table></figure>
<p>对于一个已经建立的tcp连接。如果在<code>keepalive_time</code>时间内双方没有任何的数据包传输，则开启<code>keepalive</code>功能的一端将发送<code>keepalive</code>数据包，若没有收到应答，则每隔<code>keepalive_intvl</code>时间再发送该数据包，发送<code>keepalive_probes</code>次。一直没有 收到应答，则发送rst包关闭连接。若收到应答，则将计时器清零。<br>例如★：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sk-&gt;keepalive_probes = <span class="number">3</span>;</span><br><span class="line">sk-&gt;keepalive_time   = <span class="number">30</span>;</span><br><span class="line">sk-&gt;keepalive_intvl  = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>意思就是说对于tcp连接，如果一直在socket上有数据来往就不会触发keepalive,但是如果<code>30秒</code>一直没有数据往来，则keep alive开始工作：发送探测包，受到响应则认为网络，是好的，结束探测；如果没有相应就每隔1秒发探测包，一共发送3次，3次后仍没有相应，就关闭连接，也就是从网络开始断到你的socket能够意识到网络异常，最多花<code>33秒</code>。但是如果没有设置keep alive，可能你在你的<code>socket（阻塞性）</code>的上面，接收: recv会一直阻塞不能返回，除非对端主动关闭连接，因为recv不知道socket断了。发送：取决于数据量的大小，只要底层协议站的buffer能放下你的发送数据，应用程序级别的send就会一直成功返回。 直到buffer满，甚至buffer满了还要阻塞一段时间试图等待buffer空闲。所以你对send的返回值的检查根本检测不到失败。开启了keep alive功能，你直接通过发送接收的函数返回值就可以知道网络是否异常。<br>设置的方法（应用层）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> keepalive = <span class="number">1</span>; <span class="comment">// 开启keepalive属性</span></span><br><span class="line"><span class="keyword">int</span> keepidle = <span class="number">60</span>; <span class="comment">// 如该连接在60秒内没有任何数据往来,则进行探测</span></span><br><span class="line"><span class="keyword">int</span> keepinterval = <span class="number">5</span>; <span class="comment">// 探测时发包的时间间隔为5 秒</span></span><br><span class="line"><span class="keyword">int</span> keepcount = <span class="number">3</span>; <span class="comment">// 探测尝试的次数.如果第1次探测包就收到响应了,则后2次的不再发.</span></span><br><span class="line">setsockopt(rs, SOL_SOCKET, SO_KEEPALIVE, (<span class="keyword">void</span> *)&amp;keepalive , <span class="keyword">sizeof</span>(keepalive ));</span><br><span class="line">setsockopt(rs, SOL_TCP, TCP_KEEPIDLE, (<span class="keyword">void</span>*)&amp;keepidle , <span class="keyword">sizeof</span>(keepidle ));</span><br><span class="line">setsockopt(rs, SOL_TCP, TCP_KEEPINTVL, (<span class="keyword">void</span> *)&amp;keepinterval , <span class="keyword">sizeof</span>(keepinterval ));</span><br><span class="line">setsockopt(rs, SOL_TCP, TCP_KEEPCNT, (<span class="keyword">void</span> *)&amp;keepcount , <span class="keyword">sizeof</span>(keepcount ));</span><br></pre></td></tr></table></figure>
<ul>
<li>2.select和keep alive的关系<br>select是为单个线程使用多个socket而设计的，跟检测连接无关，如果只是检测一个socket的话，没有必要使用select。开了keepalive机能的话，每次调用<code>recv或send</code>时检查<code>返回值</code>，判断是否出错或为0.如果出错，再检查<code>errno</code>查资料，看哪个或哪几个错误号表示链接断了或不存在就可以了。<br>另外，谁想定期检查连接状况,谁就启用keep alive。另一端可以不起，只是被动地对探测包进行响应，这种响应是tcp协议的基本要求，跟keep alive无关。并不需要客户端和服务器端都开启keep alive。</li>
</ul>
<ul>
<li>3.测试结果<br>按照例★的值在一端的socket上开启keep alive，然后阻塞在一个recv或者不停的send，这个时候拔了网线，测试从拔掉网线到recv/send返回失败的时间。<br>在<code>linux kernel</code>里头的测试发现，对于<code>阻塞型</code>的socket，当recv的时候，如果没有设置keep alive，即使<code>网线拔掉或者ifdown</code>，recv很长时间不会返回，最长达<code>17分钟</code>，虽然这个时间比linux的默认超时时间（）短了很多。但是如果 设置了keep alive，基本都在<code>keepalive_time + keepalive_probes * keepalive_intvl</code> =33秒内返回错误。<blockquote>
<p><font color=Red>但是对于循环不停send的socket，当拔掉网线后，会持续一段时间send返 回成功（0~10秒左右，取决 于发送数据的量），然后send<code>阻塞</code>，因为协议层的buffer满了，在等待buffer空闲，大概90秒左右后才会返回错误。由此看来，send的时 候，keep alive似乎没有起到作用，这个原因至今也不清楚。后来通过给send之前设置timer来解决的。</font></p>
</blockquote>
</li>
</ul>
]]></content>
      <tags>
        <tag>socket</tag>
      </tags>
  </entry>
  <entry>
    <title>讲给谁听</title>
    <url>/2015/03/29/%E8%AE%B2%E7%BB%99%E8%B0%81%E5%90%AC/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="" />
    <label for="hbePass">您好, 这里需要密码.</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="184a30cb3629d18329a12da7f2b818117c31df18b09ea1ed5db1336effaa9d5f">b14fc54338ecf205576f41ed6cf37d2b46c3646fbecb298d435d5d5b1fbd946628da96951068332ce5776ae2f835992ae79563ef0bf6f063e41ffc0ea3dba22fd3cc5318c298b7862ef800b06183f944b4cfcc4e2be07f87dcf12fadbd045a2ad7a6a9dd125380eb46a55d93a09e1cba5a2efe0d96761f9bc6cba6f27f77843f20eff1b34ee1b78a5747d25091b047c54d6423bd95b1e5fab78341810e9d22502a21616dbfbdf9a27ef77ed0a56138f9242a0a1992c76c05969f54d7e3047f4c14c0b7ad10f8fe00c2afe679ec79e9e8f2edd7ac789bee9debaa6896a77bb4098fce652a33f6b34b40afa1187fb4395751ff4da3a48e8bef901d4985122af777d4cd0b44762579553cbf204ff3ca8756bc1e35d6a9a510ba89536b124a140fd48ee41c4887f7367026c46bad6cc77704939ff83f52ec5fb243cb889060653a9570ff2ebf93d54b49962a89828a56bb7eedb5e4fcc9eb44be0a815aa11e262c3540ea90b7dbe4d79a5ad9b2b36551b80fa797b7de122605b2423f709031e975b4416ac9486b8daa65f2412af1a1986c6b7e93adcb2ff84ed7a37bea99775af6377cda7213d365389a8b2733d08979067663c1cdf40a59ae2b6c615c5ee18563ae42b109a286c0f562d89a636e956db4c2ccc30f049c7ad42e6df38ff4159503c5c47f719925b230cb4d1f05920b24fb9a82f2353bfaf42dc12c8d3c1195a1206418066b7f8205f974ef8c89fbb8256d9d2f27f65aa9c67471d0690f59905527bfb3804afa5ae0745d71ab6196bfbaa2dec4a1c033c59432beb31ea0fc8abdbeb4c825ff8de845f1700fec0b3cd4cfbd34c2a918fb7077ac772b98874cf7acbf52e4055d4c74441fca2e29319fe9614b226a5d5f5cb72dc774a1efb2c10f76e91a892dd69796b765b23611cd31e819b0c6529d5d41cd20bca3b5fd5d74db095b9e9799384d8a403f7b9efc6f220addc2961606a6b7fb88ee273f0a3d2e70d87713dfedc416c195c5fa1635c808ef670d2d214fd077e447db1e87d92465a2c6e767dc0285388f13472746b5e1c7389ba2e5d7a7b0a302d1e86a69689b0d0f139e4997107f12a20c3c2ca6381ad0579c9f3beb9767bab9ae558b8d05754013d877a7d5535b053e2e0b2e877c7b76662cd96a3917a49bb5a7339069fa310d00b3e6d10a8ee631f4dae2db43f72fd15baf5a5125e47bda73d0e82f897d0d9faddb33a98d55dad5d79f29dc49f6fc0a4f8f8e56dff3f3bd1d4ce70da448c4fabb15f322ebbc0efbfc6ea9da77691c61a0f4dce6509ee1527ad05ab2dac3b501a6b49e0c307182213b0f962dd6628498c1efa6a8eec7d0599e10b76d3750b0cda1385d3e2231e61fccf4ae779c617778ad5a7ecef9f702fd262bfddb8e2dbbca3a926c3e2964effcf051d399597ab8b5da2382fdda1f0d6b1b7dbbe81f52f6ce564bd8f4e42995fdd482ca7bf7b7396dd79a64fd3515b26a61a52825ead2e3ba27609294577048b7e1b1335d36f7d37e1b640e5f0fb2442c4ed4c3eb50c0e82146b36ffd0207c81cca5ebfaf2829b3c2702df43fb379421ed5e2d61a86185db7a83d8b8a4b6b0e32ee4b1914bd66e1f512dc9e328d243075acc6938538d22819c2a789bce8083af5e965cec01c9089fe8737877760c2820d68bb1031120ab2443fbb98e3ba96a35ecd0fb0a8c007baa3ac00ef21fbd03d16acb1eae26c944892bc20a22ab82cfcd63a70584c4b6ff16c0ded7fe8600989a2544089f0cb5b62324657d40b93c607be475de0f326c4c6089430bc80478be0816aa0aa9ea89fc461964808c92edc52465e61dba5316a76b603765c6141cc96d022dd7f52ffca9a322fd6a02b7c4263a295f1b0edfede1f18fd088c618aeb1c37d69f4f1851c2eb761c3754cdac960d3ff8fd0971397621a0fb275665cb4c3c7d9776224eb0c144e62e02c68ee188e23b7bd0b2bd788fcd682a036603baf4b99d81dc10d94dc5c0450c1551083820ac8f3d1f9c5e8586b9d2c7524e254d605a9d54cd2edd6d44d1380acabfb169d34822a8e7354516a0b701d558df3de411996093f411879dfb476f8ff8775256d32493dbe45516efb841d80614936cf7198355cd493406a06ed67a7fde3ee298e935cec19f950c0ba389fa5dd57468402f01156acd1a59df32497181abfe45cfd3496c07c281955783fba8597fd2cec8b6eb6ded0635f4afd537daaeb0c75ce0902c6b8e5f3766456be8be992b24322c0b8a4d4c1e5cbab4f2e77fc5518c0b2f000f5d1e9cf2ba1c82e8cc0a63f3dbc3d0d84f57c9026701003e7c0c56bde51f99c5e02e416a3c350b0af9191e32ae44a3ebc89bb0d08c22669090d3ee82f192cc603629b250b331bbd287c6dfb57ade7721712b08994734fab9a8e9f070d6c9f7d4bfb63163e148415bf472c204dea8a300beeee4701b7479b079febbd41a3b5d44c82a8da7f544e45c529c583affa814e339363de009eb0b16d3e5311d4aa59b33cae463abfb668afc5b0822594d25b5da9ba6221ae5bd475b70b9d1864026b07eb21c2902690ccf5a1207d8e8f53cc389849a060eebc9edd3471f1de1999e38d531263dcdf3587cfc51e17057ec0a00519d9a0f94426553e960bb9ad6df5040a6ced4446a6c2c020f1568913803ce4e6479a952a1ab51ca52f70471ae70c4744253f5d8a56c3f6bdff7064f71aa274ce36eb06cdf8f5c4256662b80dce889979f2f5cae1cecfae7ceaddcda6a175ed47d3e2c2c3d3dc14045b2864d0205e537dd3a0ef1f00da139e985cf70babb471bdd6fed408e964e0b844f2770dbd7215777481fa6b6bf0f69dfbda24616cddb5f192c4747d932a2946c03eb5eaaed701002f4fee5ee72e8b253ba174eaebecf83622b37e9b10f9154e2a7a91b6fced8afea0cad0a7f0b8e634aa4f822b6140a3ac47b673081ce67b5debf06a12b4021ae2852de076d00ec4f0fd92a3579a6c968e52cee46865983acef430c4c240eee3ee918dc296f6d5f8570e7f8d86ec9c9053f24f45d2c7bfeba34cfc061262b218ebe07a70b23c695f28ad59ca4e4cfc7433fe1e8c7b66cba615afe124d90fb87324ca6da120fb859eda843928953bf98a15d9b251e2b1c5e6d254de64e0c307a4fa25da20322fb46bfe06aa7e80fb7fe92bda790274034088353ea8b9012c3f57354cf816ec84ed545f84cfde35a90ad25dffe727a9d83c2a1080d333d3e45bf843c8d9104d77b18ad79e7c65a49d33cb51ba4203cda92a406392d9e870a9f45cddd984190b0dd8b3f13ae160f931fc87a566a98d498671e0cb49566126633554cb8ad8e8d20926f136fd9a90625baf13afb22905c95fe3da7b3223578aff59cb4c5f4ea9b7b6b891090fdd0e8029fbc9d093ae87cc757af528f53310c13dbe5c3cb6257c2626761d9ee2824619755149b78032c07a3ad32a10bf24511c5353e1fa6804e9303fb11d21d1db671dc1a8b317ffb2ffa7c75cacd9375d1a8e5daf629437589bd1cf995725f443d156c329819abc1e3885b6803ee7c868d4ab8d2309ed82d5a4ccbee585acbb0ee681528d73feca97af28ce61c7d0109730d0e3441c87fa17796ccfa1bb0fc2dc943871d37c14b35f8f89deb29e8b37e54a8f8ece16174e39291a1f6c8439e14d723913b84a195498a2b8d38305688d9496f306506df1ff793dccef022f52cb2fa5ebcebdb064580dc0738b74b28451f274c877a791fc81ad894fa229808a0180f54a001664d0013bbe393c5058c917e910cc8cb6d0e021dbf7872499b925f2a40ad4723d280957d6bea9623f4272f6324137cd48f6810f64c67e2355f975a51af4c2a522bdd10f52bef5ef4ac929b4a28d8a9f7d4446401e31f1694bb2f0da5b4a8aaf662800fe891d8ca2d29447cc7c7477819e13e2c8ece0488e7b251ef144e1a47e375f182e5e2110c45cf9744e1640c4ac4c434f03d0c05a6eb071f759a660c87605172eefb2dfa9fb67f8cba16ffbbc51b2e02eff8adc2092ff673ac8bb673c2c5723b7475f6921b3863afd687fc90ffc2c8ee7448e66be4c5417043077078c5ddae71a09f7886754b74fed3853ce75121676bf3940ee16a8e5ded3b5a5621ff260964ec2cd548d88653381607d6b6a27f51c8e947ae89f1f6517ddaf8cd0d1e7206596c9794362a14d0be2d947c0b6d4914d55c82e2b0aabaa5889e85c8f1e345e966ba3cc8e19fc72b35bad5dafb86b82a449e799565ad955f2e34102c836eea10b8a62bdec9ce2ef07c7761345c3231b19fbd65e2df6cc1f6737f6f14b2719aaa5e5331037a00b7cbb87d387124846b8bc59d4e2fbbadb8c71fac21d0ab197e039cafc47ec929830b6bd44328f1e26eba2cab68ba8795a639185a1ef8a7e02e695e4f7a3ddaf14bca4728ad92eb6fd32933de7ec28926ac7ad8fdb073e3f63201109d29ed992d2c64a270a7c1f787223c7e22e926a065922b74b08de23d289eb91dc66a2e98170d29a4dc84cd75d53724df61922aae9f14c432363c1c87f17ff965c7623820d552e2d227b3a704a842cead96967646b4dd87b6e5daad133998880f921c53ba02e83fef152b1d80ad77c21aa0cbd11bb632419dfb17e9274879db2ab452394c159d5a1480932065e1c2abfe8890767111dddbc8872ff5901d19f6a6c27f6a3166596879edcaebf328a7eb0dfefed4eb70a63c6da51bea0ddeb3b90e783fc9221a08dcd7c84c66a85f8534b650379249456ae0dab735c1cf7221408a5f447c4014055b4fc4203f4a065e5c3cb975f6df7c6c330ed8bd77e2fd85b8dd0670941f226ef8d7c096acf29d45a388538b2b86786f6ee5bd3283bdaaab7b7d91b7fd3d3966f4e6abe79c2bd8380fd000736211781aafc82bd728011c88587cc7bc7f1f6b223b821372cd6e2ca12f8ebf48ee2f0d29d78fb90134ede3b6a2afd20819c1e19076e5c2442c1cc9edbdfeec72945a38a88b78725bae925412c9953ea26a8899509ae339e6b759681a5c6d588b0cdddade0ad9c820ca4f5a0083e176bf1b778f693d1758a512902251bacccdc452952836b0ccf74735ce4c14588dae277979d1318bea1189a47d2e190ce9c183a096198faccd06be1f5c265cb63fec3cc9f128e738b7bd16861dd223e00feef0205ff8b375b8463ea038d0ccee05a9cb56aca2acfe920237a8aba31e449cd3074037f4abe8ed363d80fd0199d9a15453ef989eeb24746ac30a40042ef07592bc64af05d3c0d766dd3b5a7d5278a232071ae7e35478e36782f0d8b69d88c0f89466d57f2ddb478136bb3fad253b3d1c64efedca0f7a50435496b24a99ef6519ef8504a4b54462556ab783b744f1c655848e5f8dc06da195073fa8c42449c1de59a28306c8781832f2ea933f46200f7564e8ef9dc86bd6cb8f30343dce628912b72c6d61188826af6e7c0ffe88c20869544d88d3bee19ed0692af59637cdf3b9692363a7e01dd4f27f168975058dddffb5676eb626a1475ebfc0894a4c7ca7a3158b87820adce69b69c4a327715fd8cf65213e73ce66422c453faeb987586c8e0ffc00bd77d803ab8e8bac67cdd351469aa777af9f81f050a94cfe4ed6f61677438c6f6f53aec17de3032cd5d9fe5e435ffd91d7d4d31b7f9ef893296ae68dd0170f198cd87d0a8c8869ac5d27e568db43b6c4fd59651695881abfd4404ab55b98257d4e399fb759016925696431f6d51464a192387efbaee873b61e3172676d40f22e305505b42c9050661b9a4b609eb379dc401aba78300c6a2df749b41ba4db355819a4b0af02e555281d9c4776f082347ce4aa8c52cfa57ca0049258dd6f354f95bf1cb714811a353c9cf98180122021d83ee8f33c52c8506ee2cea86f082ef66ac6c3cdb920d538b034339f15a6982194696fa3684e48d7c1d1ad84202feebdcea53507e7c1d81358172e1e0f19c28b55b9e1a65824f4b964fca75f881fe5577c9b3771ea119b3a7c436ee07bfdfb237c4fc82343048f1103e3aef8d98815e21c1f0524c6b04a6c0407ced44b07a768f343b0c9026083870540e473f8c40182a2e279d2db5845eaa713242775189f0e497eeab911645791180fa2c1c7fc7835600631ee1596da53a93d9b205e4176ea02814388fd81ba90c6a54495b1caafc154bc2e4df10e41fe99c6014798b675c36096c7d34eb51453104d20563d6a41a270dec2bc688a859d4786e5864642395c697661b62b3c25bb60a7d6cc577684e8c6bbfb1c8cdaf4f2f3df18828bd7b5423d767f5b3b0e18980c82b7c6fba5cc4680d62dab5f20b5cffffe5c767131d433887ebde236a05f08eeb7a22f2676f07a783f9e293ae188a98146419184f8615e470569828bedd3b845d538d65c52e58de6295ffd8a8e57cf2ea1044df3eeb180207fcfb08868268e87d72c25b5e7ef2624c8f03405addc57f55f305a251bcc360b33b9892091401315ba103199f5c94345f08b22c992ff92cbf01c70ca27f2d11eb0bbd52279ef5c87d9f9</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>值得推荐的C/C++框架和库</title>
    <url>/2016/03/11/%E5%80%BC%E5%BE%97%E6%8E%A8%E8%8D%90%E7%9A%84C-C-%E6%A1%86%E6%9E%B6%E5%92%8C%E5%BA%93/</url>
    <content><![CDATA[<h2 id="值得学习的C语言开源项目"><a href="#值得学习的C语言开源项目" class="headerlink" title="值得学习的C语言开源项目"></a>值得学习的C语言开源项目</h2><h3 id="1-Webbench"><a href="#1-Webbench" class="headerlink" title="1. Webbench"></a>1. Webbench</h3><p>Webbench是一个在linux下使用的非常简单的网站压测工具。它使用fork()模拟多个客户端同时访问我们设定的URL，测试网站在压力下工作的性能，最多可以模拟3万个并发连接去测试网站的负载能力。Webbench使用C语言编写, 代码实在太简洁，源码加起来不到600行。<br>下载链接：<a href="http://home.tiscali.cz/~cz210552/webbench.html">http://home.tiscali.cz/~cz210552/webbench.html</a></p>
<a id="more"></a>

<h3 id="2-Tinyhttpd"><a href="#2-Tinyhttpd" class="headerlink" title="2. Tinyhttpd"></a>2. Tinyhttpd</h3><p>tinyhttpd是一个超轻量型Http Server，使用C语言开发，全部代码只有502行(包括注释)，附带一个简单的Client，可以通过阅读这段代码理解一个 Http Server 的本质。</p>
<p>下载链接：<a href="http://sourceforge.net/projects/tinyhttpd/">http://sourceforge.net/projects/tinyhttpd/</a></p>
<h3 id="3-cJSON"><a href="#3-cJSON" class="headerlink" title="3. cJSON"></a>3. cJSON</h3><p>cJSON是C语言中的一个JSON编解码器，非常轻量级，C文件只有500多行，速度也非常理想。</p>
<p>cJSON也存在几个弱点，虽然功能不是非常强大，但cJSON的小身板和速度是最值得赞赏的。其代码被非常好地维护着，结构也简单易懂，可以作为一个非常好的C语言项目进行学习。</p>
<p>项目主页:<a href="http://sourceforge.net/projects/cjson/">http://sourceforge.net/projects/cjson/</a></p>
<h3 id="4-CMockery"><a href="#4-CMockery" class="headerlink" title="4. CMockery"></a>4. CMockery</h3><p>cmockery是google发布的用于C单元测试的一个轻量级的框架。它很小巧，对其他开源包没有依赖，对被测试代码侵入性小。cmockery的源代码行数不到3K，你阅读一下will_return和mock的源代码就一目了然了。</p>
<p><code>主要特点：</code></p>
<ul>
<li>免费且开源，google提供技术支持；</li>
<li>轻量级的框架，使测试更加快速简单；</li>
<li>避免使用复杂的编译器特性，对老版本的编译器来讲，兼容性好;</li>
<li>并不强制要求待测代码必须依赖C99标准，这一特性对许多嵌入式系统的开发很有用</li>
</ul>
<p>下载链接：<a href="https://github.com/google/cmockery">https://github.com/google/cmockery</a></p>
<h3 id="5-Libev"><a href="#5-Libev" class="headerlink" title="5. Libev"></a>5. Libev</h3><p>libev是一个开源的事件驱动库，基于epoll，kqueue等OS提供的基础设施。其以高效出名，它可以将IO事件，定时器，和信号统一起来，统一放在事件处理这一套框架下处理。基于Reactor模式，效率较高，并且代码精简（4.15版本8000多行），是学习事件驱动编程的很好的资源。</p>
<p>下载链接：<a href="http://software.schmorp.de/pkg/libev.html">http://software.schmorp.de/pkg/libev.html</a></p>
<h3 id="6-Memcached"><a href="#6-Memcached" class="headerlink" title="6. Memcached"></a>6. Memcached</h3><p>Memcached 是一个高性能的分布式内存对象缓存系统，用于动态Web应用以减轻数据库负载。它通过在内存中缓存数据和对象来减少读取数据库的次数，从而提供动态数据库驱动网站的速度。Memcached 基于一个存储键/值对的 hashmap。Memcached-1.4.7的代码量还是可以接受的，只有10K行左右。</p>
<p>下载地址：<a href="http://memcached.org/">http://memcached.org/</a></p>
<h3 id="7-Lua"><a href="#7-Lua" class="headerlink" title="7. Lua"></a>7. Lua</h3><p>Lua很棒，Lua是巴西人发明的，这些都令我不爽，但是还不至于脸红，最多眼红。</p>
<p>让我脸红的是Lua的源代码，百分之一百的ANSI C，一点都不掺杂。在任何支持ANSI C编译器的平台上都可以轻松编译通过。我试过，真是一点废话都没有。Lua的代码数量足够小，5.1.4仅仅1.5W行，去掉空白行和注释估计能到1W行。</p>
<p>下载地址：<a href="http://www.lua.org/">http://www.lua.org/</a></p>
<h3 id="8-SQLite"><a href="#8-SQLite" class="headerlink" title="8. SQLite"></a>8. SQLite</h3><p>SQLite是一个开源的嵌入式关系数据库，实现自包容、零配置、支持事务的SQL数据库引擎。 其特点是高度便携、使用方便、结构紧凑、高效、可靠。足够小，大致3万行C代码，250K。</p>
<p>下载地址：<a href="http://www.sqlite.org/">http://www.sqlite.org/</a> 。</p>
<h3 id="9-UNIX-v6"><a href="#9-UNIX-v6" class="headerlink" title="9. UNIX v6"></a>9. UNIX v6</h3><p>UNIX V6 的内核源代码包括设备驱动程序在内 约有1 万行，这个数量的源代码，初学者是能够充分理解的。有一种说法是一个人所能理解的代码量上限为1 万行，UNIX V6的内核源代码从数量上看正好在这个范围之内。看到这里，大家是不是也有“如果只有1万行的话没准儿我也能学会”的想法呢？</p>
<p>另一方面，最近的操作系统，例如Linux 最新版的内核源代码据说超过了1000 万行。就算不是初学者，想完全理解全部代码基本上也是不可能的。</p>
<p>下载地址：<a href="http://minnie.tuhs.org/cgi-bin/utree.pl?file=V6">http://minnie.tuhs.org/cgi-bin/utree.pl?file=V6</a></p>
<h3 id="10-NETBSD"><a href="#10-NETBSD" class="headerlink" title="10. NETBSD"></a>10. NETBSD</h3><p>NetBSD是一个免费的，具有高度移植性的 UNIX-like 操作系统，是现行可移植平台最多的操作系统，可以在许多平台上执行，从 64bit alpha 服务器到手持设备和嵌入式设备。NetBSD计划的口号是：”Of course it runs NetBSD”。它设计简洁，代码规范，拥有众多先进特性，使得它在业界和学术界广受好评。由于简洁的设计和先进的特征，使得它在生产和研究方面，都有卓越的表现，而且它也有受使用者支持的完整的源代码。许多程序都可以很容易地通过NetBSD Packages Collection获得。</p>
<p>下载地址：<a href="http://www.netbsd.org/">http://www.netbsd.org/</a></p>
<h2 id="C-资源大全"><a href="#C-资源大全" class="headerlink" title="C++ 资源大全"></a>C++ 资源大全</h2><blockquote>
<p>关于 C++ 框架、库和资源的一些汇总列表，内容包括：标准库、Web应用框架、人工智能、数据库、图片处理、机器学习、日志、代码分析等。</p>
</blockquote>
<h3 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a>标准库</h3><p>C++标准库，包括了STL容器，算法和函数等。</p>
<ul>
<li><a href="http://en.wikipedia.org/wiki/C%2B%2B_Standard_Library">C++ Standard Library</a>：是一系列类和函数的集合，使用核心语言编写，也是C++ISO自身标准的一部分。</li>
<li><a href="http://en.wikipedia.org/wiki/Standard_Template_Library">Standard Template Library</a>：标准模板库</li>
<li><a href="http://en.wikipedia.org/wiki/C_POSIX_library">C POSIX library</a> ： POSIX系统的C标准库规范</li>
<li><a href="https://github.com/cplusplus">ISO C++ Standards Committee</a> ：C++标准委员会</li>
</ul>
<h3 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h3><h4 id="C-通用框架和库"><a href="#C-通用框架和库" class="headerlink" title="C++通用框架和库"></a>C++通用框架和库</h4><ul>
<li>Apache C++ Standard Library：是一系列算法，容器，迭代器和其他基本组件的集合</li>
<li>ASL ：Adobe源代码库提供了同行的评审和可移植的C++源代码库。</li>
<li>Boost ：大量通用C++库的集合。</li>
<li>BDE ：来自于彭博资讯实验室的开发环境。</li>
<li>Cinder：提供专业品质创造性编码的开源开发社区。</li>
<li>Cxxomfort：轻量级的，只包含头文件的库，将C++ 11的一些新特性移植到C++03中。</li>
<li>Dlib：使用契约式编程和现代C++科技设计的通用的跨平台的C++库。</li>
<li>EASTL ：EA-STL公共部分</li>
<li>ffead-cpp ：企业应用程序开发框架</li>
<li>Folly：由Facebook开发和使用的开源C++库</li>
<li>JUCE ：包罗万象的C++类库，用于开发跨平台软件</li>
<li>libPhenom：用于构建高性能和高度可扩展性系统的事件框架。</li>
<li>LibSourcey ：用于实时的视频流和高性能网络应用程序的C++11 evented IO</li>
<li>LibU ： C语言写的多平台工具库</li>
<li>Loki ：C++库的设计，包括常见的设计模式和习语的实现。</li>
<li>MiLi ：只含头文件的小型C++库</li>
<li>openFrameworks ：开发C++工具包，用于创意性编码。</li>
<li>Qt ：跨平台的应用程序和用户界面框架</li>
<li>Reason ：跨平台的框架，使开发者能够更容易地使用Java，.Net和Python，同时也满足了他们对C++性能和优势的需求。</li>
<li>ROOT ：具备所有功能的一系列面向对象的框架，能够非常高效地处理和分析大量的数据，为欧洲原子能研究机构所用。</li>
<li>STLport：是STL具有代表性的版本</li>
<li>STXXL：用于额外的大型数据集的标准模板库。</li>
<li>Ultimate++ ：C++跨平台快速应用程序开发框架</li>
<li>Windows Template Library：用于开发Windows应用程序和UI组件的C++库</li>
<li>Yomm11 ：C++11的开放multi-methods.</li>
</ul>
<h4 id="人工智能"><a href="#人工智能" class="headerlink" title="人工智能"></a>人工智能</h4><ul>
<li>btsk ：游戏行为树启动器工具</li>
<li>Evolving Objects：基于模板的，ANSI C++演化计算库，能够帮助你非常快速地编写出自己的随机优化算法。</li>
<li>Neu：C++11框架，编程语言集，用于创建人工智能应用程序的多用途软件系统。</li>
</ul>
<h4 id="异步事件循环"><a href="#异步事件循环" class="headerlink" title="异步事件循环"></a>异步事件循环</h4><ul>
<li>Boost.Asio：用于网络和底层I/O编程的跨平台的C++库。</li>
<li>libev ：功能齐全，高性能的时间循环，轻微地仿效libevent，但是不再像libevent一样有局限性，也修复了它的一些bug。</li>
<li>libevent ：事件通知库</li>
<li>libuv ：跨平台异步I/O。</li>
</ul>
<h4 id="音频"><a href="#音频" class="headerlink" title="音频"></a>音频</h4><blockquote>
<p>音频，声音，音乐，数字化音乐库</p>
</blockquote>
<ul>
<li>FMOD ：易于使用的跨平台的音频引擎和音频内容的游戏创作工具。</li>
<li>Maximilian ：C++音频和音乐数字信号处理库</li>
<li>OpenAL ：开源音频库—跨平台的音频API</li>
<li>Opus：一个完全开放的，免版税的，高度通用的音频编解码器</li>
<li>Speex：免费编解码器，为Opus所废弃</li>
<li>Tonic： C++易用和高效的音频合成</li>
<li>Vorbis： Ogg Vorbis是一种完全开放的，非专有的，免版税的通用压缩音频格式。</li>
</ul>
<h4 id="生态学"><a href="#生态学" class="headerlink" title="生态学"></a>生态学</h4><blockquote>
<p>生物信息，基因组学和生物技术</p>
</blockquote>
<ul>
<li>libsequence：用于表示和分析群体遗传学数据的C++库。</li>
<li>SeqAn：专注于生物数据序列分析的算法和数据结构。</li>
<li>Vcflib ：用于解析和处理VCF文件的C++库</li>
<li>Wham：直接把联想测试应用到BAM文件的基因结构变异。</li>
</ul>
<h4 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h4><blockquote>
<p>压缩和归档库</p>
</blockquote>
<ul>
<li>bzip2：一个完全免费，免费专利和高质量的数据压缩</li>
<li>doboz：能够快速解压缩的压缩库</li>
<li>PhysicsFS：对各种归档提供抽象访问的库，主要用于视频游戏，设计灵感部分来自于Quake3的文件子系统。</li>
<li>KArchive：用于创建，读写和操作文件档案（例如zip和 tar）的库，它通过QIODevice的一系列子类，使用gzip格式，提供了透明的压缩和解压缩的数据。</li>
<li>LZ4 ：非常快速的压缩算法</li>
<li>LZHAM ：无损压缩数据库，压缩比率跟LZMA接近，但是解压缩速度却要快得多。</li>
<li>LZMA ：7z格式默认和通用的压缩方法。</li>
<li>LZMAT ：及其快速的实时无损数据压缩库</li>
<li>miniz：单一的C源文件，紧缩/膨胀压缩库，使用zlib兼容API，ZIP归档读写，PNG写方式。</li>
<li>Minizip：Zlib最新bug修复，支持PKWARE磁盘跨越，AES加密和IO缓冲。</li>
<li>Snappy ：快速压缩和解压缩</li>
<li>ZLib ：非常紧凑的数据流压缩库</li>
<li>ZZIPlib：提供ZIP归档的读权限。</li>
</ul>
<h4 id="并发性"><a href="#并发性" class="headerlink" title="并发性"></a>并发性</h4><blockquote>
<p>并发执行和多线程</p>
</blockquote>
<ul>
<li>Boost.Compute ：用于OpenCL的C++GPU计算库</li>
<li>Bolt ：针对GPU进行优化的C++模板库</li>
<li>C++React ：用于C++11的反应性编程库</li>
<li>Intel TBB ：Intel线程构件块</li>
<li>Libclsph：基于OpenCL的GPU加速SPH流体仿真库</li>
<li>OpenCL ：并行编程的异构系统的开放标准</li>
<li>OpenMP：OpenMP API</li>
<li>Thrust ：类似于C++标准模板库的并行算法库</li>
<li>HPX ：用于任何规模的并行和分布式应用程序的通用C++运行时系统</li>
<li>VexCL ：用于OpenCL/CUDA 的C++向量表达式模板库。</li>
</ul>
<h4 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h4><ul>
<li>C++ B-tree ：基于B树数据结构，实现命令内存容器的模板库</li>
<li>Hashmaps： C++中开放寻址哈希表算法的实现</li>
</ul>
<h4 id="密码学"><a href="#密码学" class="headerlink" title="密码学"></a>密码学</h4><ul>
<li>Bcrypt ：一个跨平台的文件加密工具，加密文件可以移植到所有可支持的操作系统和处理器中。</li>
<li>BeeCrypt：</li>
<li>Botan： C++加密库</li>
<li>Crypto++：一个有关加密方案的免费的C++库</li>
<li>GnuPG： OpenPGP标准的完整实现</li>
<li>GnuTLS ：实现了SSL，TLS和DTLS协议的安全通信库</li>
<li>Libgcrypt</li>
<li>libmcrypt</li>
<li>LibreSSL：免费的SSL/TLS协议，属于2014 OpenSSL的一个分支</li>
<li>LibTomCrypt：一个非常全面的，模块化的，可移植的加密工具</li>
<li>libsodium：基于NaCI的加密库，固执己见，容易使用</li>
<li>Nettle 底层的加密库</li>
<li>OpenSSL ： 一个强大的，商用的，功能齐全的，开放源代码的加密库。</li>
<li>Tiny AES128 in C ：用C实现的一个小巧，可移植的实现了AES128ESB的加密算法</li>
</ul>
<h4 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h4><blockquote>
<p>数据库，SQL服务器，ODBC驱动程序和工具</p>
</blockquote>
<ul>
<li>hiberlite ：用于Sqlite3的C++对象关系映射</li>
<li>Hiredis： 用于Redis数据库的很简单的C客户端库</li>
<li>LevelDB： 快速键值存储库</li>
<li>LMDB：符合数据库四大基本元素的嵌入键值存储</li>
<li>MySQL++：封装了MySql的C API的C++ 包装器</li>
<li>RocksDB：来自Facebook的嵌入键值的快速存储</li>
<li>SQLite：一个完全嵌入式的，功能齐全的关系数据库，只有几百KB，可以正确包含到你的项目中。</li>
</ul>
<h4 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h4><blockquote>
<p>调试库， 内存和资源泄露检测，单元测试</p>
</blockquote>
<ul>
<li>Boost.Test：Boost测试库</li>
<li>Catch：一个很时尚的，C++原生的框架，只包含头文件，用于单元测试，测试驱动开发和行为驱动开发。</li>
<li>CppUnit：由JUnit移植过来的C++测试框架</li>
<li>CTest：CMake测试驱动程序</li>
<li>googletest：谷歌C++测试框架</li>
<li>ig-debugheap：用于跟踪内存错误的多平台调试堆</li>
<li>libtap：用C语言编写测试</li>
<li>MemTrack —用于C++跟踪内存分配</li>
<li>microprofile- 跨平台的网络试图分析器</li>
<li>minUnit ：使用C写的迷你单元测试框架，只使用了两个宏</li>
<li>Remotery：用于web视图的单一C文件分析器</li>
<li>UnitTest++：轻量级的C++单元测试框架</li>
</ul>
<h4 id="游戏引擎"><a href="#游戏引擎" class="headerlink" title="游戏引擎"></a>游戏引擎</h4><ul>
<li>Cocos2d-x ：一个跨平台框架，用于构建2D游戏，互动图书，演示和其他图形应用程序。</li>
<li>Grit ：社区项目，用于构建一个免费的游戏引擎，实现开放的世界3D游戏。</li>
<li>Irrlicht ：C++语言编写的开源高性能的实时#D引擎</li>
<li>Polycode：C++实现的用于创建游戏的开源框架（与Lua绑定）。</li>
</ul>
<h4 id="图形用户界面"><a href="#图形用户界面" class="headerlink" title="图形用户界面"></a>图形用户界面</h4><ul>
<li>CEGUI ： 很灵活的跨平台GUI库</li>
<li>FLTK ：快速，轻量级的跨平台的C++GUI工具包。</li>
<li>GTK+： 用于创建图形用户界面的跨平台工具包</li>
<li>gtkmm ：用于受欢迎的GUI库GTK+的官方C++接口。</li>
<li>imgui：拥有最小依赖关系的立即模式图形用户界面</li>
<li>libRocket ：libRocket 是一个C++ HTML/CSS 游戏接口中间件</li>
<li>MyGUI ：快速，灵活，简单的GUI</li>
<li>Ncurses：终端用户界面</li>
<li>QCustomPlot ：没有更多依赖关系的Qt绘图控件</li>
<li>Qwt ：用户与技术应用的Qt 控件</li>
<li>QwtPlot3D ：功能丰富的基于Qt/OpenGL的C++编程库，本质上提供了一群3D控件</li>
<li>OtterUI ：OtterUI 是用于嵌入式系统和互动娱乐软件的用户界面开发解决方案</li>
<li>PDCurses 包含源代码和预编译库的公共图形函数库</li>
<li>wxWidgets C++库，允许开发人员使用一个代码库可以为widows， Mac OS X，Linux和其他平台创建应用程序</li>
</ul>
<h4 id="图形"><a href="#图形" class="headerlink" title="图形"></a>图形</h4><ul>
<li>bgfx：跨平台的渲染库</li>
<li>Cairo：支持多种输出设备的2D图形库</li>
<li>Horde3D 一个小型的3D渲染和动画引擎</li>
<li>magnum C++11和OpenGL 2D/3D 图形引擎</li>
<li>Ogre 3D 用C++编写的一个面向场景，实时，灵活的3D渲染引擎（并非游戏引擎）</li>
<li>OpenSceneGraph 具有高性能的开源3D图形工具包</li>
<li>Panda3D 用于3D渲染和游戏开发的框架，用Python和C++编写。</li>
<li>Skia 用于绘制文字，图形和图像的完整的2D图形库</li>
<li>urho3d 跨平台的渲染和游戏引擎。</li>
</ul>
<h4 id="图像处理"><a href="#图像处理" class="headerlink" title="图像处理"></a>图像处理</h4><ul>
<li>Boost.GIL：通用图像库</li>
<li>CImg ：用于图像处理的小型开源C++工具包</li>
<li>CxImage ：用于加载，保存，显示和转换的图像处理和转换库，可以处理的图片格式包括 BMP, JPEG, GIF, PNG, TIFF, MNG, ICO, PCX, TGA, WMF, WBMP, JBG, J2K。</li>
<li>FreeImage ：开源库，支持现在多媒体应用所需的通用图片格式和其他格式。</li>
<li>GDCM：Grassroots DICOM 库</li>
<li>ITK：跨平台的开源图像分析系统</li>
<li>Magick++：ImageMagick程序的C++接口</li>
<li>MagickWnd：ImageMagick程序的C++接口</li>
<li>OpenCV ： 开源计算机视觉类库</li>
<li>tesseract-ocr：OCR引擎</li>
<li>VIGRA ：用于图像分析通用C++计算机视觉库</li>
<li>VTK ：用于3D计算机图形学，图像处理和可视化的开源免费软件系统。</li>
</ul>
<h4 id="国际化"><a href="#国际化" class="headerlink" title="国际化"></a>国际化</h4><ul>
<li>gettext ：GNU `gettext’</li>
<li>IBM ICU：提供Unicode 和全球化支持的C、C++ 和Java库</li>
<li>libiconv ：用于不同字符编码之间的编码转换库</li>
</ul>
<h4 id="Jason"><a href="#Jason" class="headerlink" title="Jason"></a>Jason</h4><ul>
<li>frozen ： C/C++的Jason解析生成器</li>
<li>Jansson ：进行编解码和处理Jason数据的C语言库</li>
<li>jbson ：C++14中构建和迭代BSON data,和Json 文档的库</li>
<li>JeayeSON：非常健全的C++ JSON库，只包含头文件</li>
<li>JSON++ ： C++ JSON 解析器</li>
<li>json-parser：用可移植的ANSI C编写的JSON解析器，占用内存非常少</li>
<li>json11 ：一个迷你的C++11 JSON库</li>
<li>jute ：非常简单的C++ JSON解析器</li>
<li>ibjson：C语言中的JSON解析和打印库，很容易和任何模型集成。</li>
<li>libjson：轻量级的JSON库</li>
<li>PicoJSON：C++中JSON解析序列化，只包含头文件</li>
<li>qt-json ：用于JSON数据和 QVariant层次间的相互解析的简单类</li>
<li>QJson：将JSON数据映射到QVariant对象的基于Qt的库</li>
<li>RapidJSON： 用于C++的快速JSON 解析生成器，包含SAX和DOM两种风格的API</li>
<li>YAJL ：C语言中快速流JSON解析库</li>
</ul>
<h4 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h4><ul>
<li>Boost.Log ：设计非常模块化，并且具有扩展性</li>
<li>easyloggingpp：C++日志库，只包含单一的头文件。</li>
<li>Log4cpp ：一系列C++类库，灵活添加日志到文件，系统日志，IDSA和其他地方。</li>
<li>templog：轻量级C++库，可以添加日志到你的C++应用程序中</li>
</ul>
<h4 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h4><ul>
<li>Caffe ：快速的神经网络框架</li>
<li>CCV ：以C语言为核心的现代计算机视觉库</li>
<li>mlpack ：可扩展的C++机器学习库</li>
<li>OpenCV：开源计算机视觉库</li>
<li>Recommender：使用协同过滤进行产品推荐/建议的C语言库。</li>
<li>SHOGUN：Shogun 机器学习工具</li>
<li>sofia-ml ：用于机器学习的快速增量算法套件</li>
</ul>
<h4 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h4><ul>
<li>Armadillo ：高质量的C++线性代数库，速度和易用性做到了很好的平衡。语法和MatlAB很相似</li>
<li>blaze：高性能的C++数学库，用于密集和稀疏算法。</li>
<li>ceres-solver ：来自谷歌的C++库，用于建模和解决大型复杂非线性最小平方问题。</li>
<li>CGal： 高效，可靠的集合算法集合</li>
<li>cml ：用于游戏和图形的免费C++数学库</li>
<li>Eigen ：高级C++模板头文件库，包括线性代数，矩阵，向量操作，数值解决和其他相关的算法。</li>
<li>GMTL：数学图形模板库是一组广泛实现基本图形的工具。</li>
<li>GMP：用于个高精度计算的C/C++库，处理有符号整数，有理数和浮点数。</li>
</ul>
<h4 id="多媒体"><a href="#多媒体" class="headerlink" title="多媒体"></a>多媒体</h4><ul>
<li>GStreamer ：构建媒体处理组件图形的库</li>
<li>LIVE555 Streaming Media ：使用开放标准协议(RTP/RTCP, RTSP, SIP) 的多媒体流库</li>
<li>libVLC ：libVLC (VLC SDK)媒体框架</li>
<li>QtAv：基于Qt和FFmpeg的多媒体播放框架，能够帮助你轻而易举地编写出一个播放器</li>
<li>SDL ：简单直控媒体层</li>
<li>SFML ：快速，简单的多媒体库</li>
</ul>
<h5 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h5><ul>
<li>ACE：C++面向对象网络变成工具包</li>
<li>Boost.Asio：用于网络和底层I/O编程的跨平台的C++库</li>
<li>Casablanca：C++ REST SDK</li>
<li>cpp-netlib：高级网络编程的开源库集合</li>
<li>Dyad.c：C语言的异步网络</li>
<li>libcurl :多协议文件传输库</li>
<li>Mongoose：非常轻量级的网络服务器</li>
<li>Muduo ：用于Linux多线程服务器的C++非阻塞网络库</li>
<li>net_skeleton ：C/C++的TCP 客户端/服务器库</li>
<li>nope.c ：基于C语言的超轻型软件平台，用于可扩展的服务器端和网络应用。 对于C编程人员，可以考虑node.js</li>
<li>Onion :C语言HTTP服务器库，其设计为轻量级，易使用。</li>
<li>POCO：用于构建网络和基于互联网应用程序的C++类库，可以运行在桌面，服务器，移动和嵌入式系统。</li>
<li>RakNet：为游戏开发人员提供的跨平台的开源C++网络引擎。</li>
<li>Tuf o ：用于Qt之上的C++构建的异步Web框架。</li>
<li>WebSocket++ ：基于C++/Boost Aiso的websocket 客户端/服务器库</li>
<li>ZeroMQ ：高速，模块化的异步通信库</li>
</ul>
<h4 id="物理学"><a href="#物理学" class="headerlink" title="物理学"></a>物理学</h4><h5 id="动力学仿真引擎"><a href="#动力学仿真引擎" class="headerlink" title="动力学仿真引擎"></a>动力学仿真引擎</h5><ul>
<li>Box2D：2D的游戏物理引擎。</li>
<li>Bullet ：3D的游戏物理引擎。</li>
<li>Chipmunk ：快速，轻量级的2D游戏物理库</li>
<li>LiquidFun：2D的游戏物理引擎</li>
<li>ODE ：开放动力学引擎-开源，高性能库，模拟刚体动力学。</li>
<li>ofxBox2d：Box2D开源框架包装器。</li>
<li>Simbody ：高性能C++多体动力学/物理库，模拟关节生物力学和机械系统，像车辆，机器人和人体骨骼。</li>
</ul>
<h5 id="机器人学"><a href="#机器人学" class="headerlink" title="机器人学"></a>机器人学</h5><ul>
<li>MOOS-IvP ：一组开源C++模块，提供机器人平台的自主权，尤其是自主的海洋车辆。</li>
<li>MRPT：移动机器人编程工具包</li>
<li>PCL ：点云库是一个独立的，大规模的开放项目，用于2D/3D图像和点云处理。</li>
<li>Robotics Library (RL)： 一个独立的C++库，包括机器人动力学，运动规划和控制。</li>
<li>RobWork：一组C++库的集合，用于机器人系统的仿真和控制。</li>
<li>ROS ：机器人操作系统，提供了一些库和工具帮助软件开发人员创建机器人应用程序。</li>
</ul>
<h5 id="科学计算"><a href="#科学计算" class="headerlink" title="科学计算"></a>科学计算</h5><ul>
<li>FFTW :用一维或者多维计算DFT的C语言库。</li>
<li>GSL：GNU科学库。</li>
</ul>
<h5 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h5><h5 id="ChaiScript-：用于C-的易于使用的嵌入式脚本语言。"><a href="#ChaiScript-：用于C-的易于使用的嵌入式脚本语言。" class="headerlink" title="ChaiScript ：用于C++的易于使用的嵌入式脚本语言。"></a>ChaiScript ：用于C++的易于使用的嵌入式脚本语言。</h5><p>Lua ：用于配置文件和基本应用程序脚本的小型快速脚本引擎。<br>luacxx：用于创建Lua绑定的C++ 11 API<br>SWIG ：一个可以让你的C++代码链接到JavaScript，Perl，PHP，Python，Tcl和Ruby的包装器/接口生成器<br>V7：嵌入式的JavaScript 引擎。<br>V8 ：谷歌的快速JavaScript引擎，可以被嵌入到任何C++应用程序中。</p>
<h5 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h5><ul>
<li>Cap’n Proto ：快速数据交换格式和RPC系统。</li>
<li>cereal ：C++11 序列化库</li>
<li>FlatBuffers ：内存高效的序列化库</li>
<li>MessagePack ：C/C++的高效二进制序列化库，例如 JSON</li>
<li>protobuf ：协议缓冲，谷歌的数据交换格式。</li>
<li>protobuf-c ：C语言的协议缓冲实现</li>
<li>SimpleBinaryEncoding：用于低延迟应用程序的对二进制格式的应用程序信息的编码和解码。</li>
<li>Thrift ：高效的跨语言IPC/RPC，用于C++，Java，Python，PHP，C#和其它多种语言中，最初由Twitter开发。<strong>注：原文有误，应该是 facebook 在2007年开发的，现在是 Apache 在维护</strong></li>
</ul>
<h5 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h5><ul>
<li>libvpx ：VP8/VP9编码解码SDK</li>
<li>FFmpeg ：一个完整的，跨平台的解决方案，用于记录，转换视频和音频流。</li>
<li>libde265 ：开放的h.265视频编解码器的实现。</li>
<li>OpenH264：开源H.364 编解码器。</li>
<li>Theora ：免费开源的视频压缩格式。</li>
</ul>
<h5 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h5><ul>
<li>CarpVM：C中有趣的VM，让我们一起来看看这个。</li>
<li>MicroPython ：旨在实现单片机上Python3.x的实现</li>
<li>TinyVM：用纯粹的ANSI C编写的小型，快速，轻量级的虚拟机。</li>
</ul>
<h5 id="Web应用框架"><a href="#Web应用框架" class="headerlink" title="Web应用框架"></a>Web应用框架</h5><ul>
<li>Civetweb ：提供易于使用，强大的，C/C++嵌入式Web服务器，带有可选的CGI，SSL和Lua支持。</li>
<li>CppCMS ：免费高性能的Web开发框架（不是 CMS）.</li>
<li>Crow ：一个C++微型web框架（灵感来自于Python Flask）</li>
<li>Kore :使用C语言开发的用于web应用程序的超快速和灵活的web服务器/框架。</li>
<li>libOnion：轻量级的库，帮助你使用C编程语言创建web服务器。</li>
<li>QDjango：使用C++编写的，基于Qt库的web框架，试图效仿Django API，因此得此名。</li>
<li>Wt ：开发Web应用的C++库。</li>
</ul>
<h5 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h5><blockquote>
<p>XML就是个垃圾，xml的解析很烦人，对于计算机它也是个灾难。这种糟糕的东西完全没有存在的理由了。-Linus Torvalds</p>
</blockquote>
<ul>
<li>Expat ：用C语言编写的xml解析库</li>
<li>Libxml2 ：Gnome的xml C解析器和工具包</li>
<li>libxml++ ：C++的xml解析器</li>
<li>PugiXML ：用于C++的，支持XPath的轻量级，简单快速的XML解析器。</li>
<li>RapidXml ：试图创建最快速的XML解析器，同时保持易用性，可移植性和合理的W3C兼容性。</li>
<li>TinyXML ：简单小型的C++XML解析器，可以很容易地集成到其它项目中。</li>
<li>TinyXML2：简单快速的C++CML解析器，可以很容易集成到其它项目中。</li>
<li>TinyXML++：TinyXML的一个全新的接口，使用了C++的许多许多优势，模板，异常和更好的异常处理。</li>
<li>Xerces-C++ ：用可移植的C++的子集编写的XML验证解析器。</li>
</ul>
<h4 id="多项混杂"><a href="#多项混杂" class="headerlink" title="多项混杂"></a>多项混杂</h4><blockquote>
<p>一些有用的库或者工具，但是不适合上面的分类，或者还没有分类。</p>
</blockquote>
<ul>
<li>C++ Format ：C++的小型，安全和快速格式化库</li>
<li>casacore ：从aips++ 派生的一系列C++核心库</li>
<li>cxx-prettyprint：用于C++容器的打印库</li>
<li>DynaPDF ：易于使用的PDF生成库</li>
<li>gcc-poison ：帮助开发人员禁止应用程序中的不安全的C/C++函数的简单的头文件。</li>
<li>googlemock：编写和使用C++模拟类的库</li>
<li>HTTP Parser ：C的http请求/响应解析器</li>
<li>libcpuid ：用于x86 CPU检测盒特征提取的小型C库</li>
<li>libevil ：许可证管理器</li>
<li>libusb：允许移动访问USB设备的通用USB库</li>
<li>PCRE：正则表达式C库，灵感来自于Perl中正则表达式的功能。</li>
<li>Remote Call Framework ：C++的进程间通信框架。</li>
<li>Scintilla ：开源的代码编辑控件</li>
<li>Serial Communication Library ：C++语言编写的跨平台，串口库。</li>
<li>SDS：C的简单动态字符串库</li>
<li>SLDR ：超轻的DNS解析器</li>
<li>SLRE： 超轻的正则表达式库</li>
<li>Stage ：移动机器人模拟器</li>
<li>VarTypes：C++/Qt4功能丰富，面向对象的管理变量的框架。</li>
<li>ZBar：‘条形码扫描器’库，可以扫描照片，图片和视频流中的条形码，并返回结果。</li>
<li>CppVerbalExpressions ：易于使用的C++正则表达式</li>
<li>QtVerbalExpressions：基于C++ VerbalExpressions 库的Qt库</li>
<li>PHP-CPP：使用C++来构建PHP扩展的库</li>
<li>Better String ：C的另一个字符串库，功能更丰富，但是没有缓冲溢出问题，还包含了一个C++包装器。</li>
</ul>
<h4 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h4><blockquote>
<p>用于创建开发环境的软件</p>
</blockquote>
<h5 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h5><p><code>C/C++编译器列表</code></p>
<ul>
<li>Clang :由苹果公司开发的</li>
<li>GCC：GNU编译器集合</li>
<li>Intel C++ Compiler ：由英特尔公司开发</li>
<li>LLVM ：模块化和可重用编译器和工具链技术的集合</li>
<li>Microsoft Visual C++ ：MSVC，由微软公司开发</li>
<li>Open WatCom ：Watcom，C，C++和Fortran交叉编译器和工具</li>
<li>TCC ：轻量级的C语言编译器</li>
</ul>
<h5 id="在线编译器"><a href="#在线编译器" class="headerlink" title="在线编译器"></a>在线编译器</h5><p><code>在线C/C++编译器列表</code></p>
<ul>
<li>codepad ：在线编译器/解释器，一个简单的协作工具</li>
<li>CodeTwist：一个简单的在线编译器/解释器，你可以粘贴的C,C++或者Java代码，在线执行并查看结果</li>
<li>coliru ：在线编译器/shell， 支持各种C++编译器</li>
<li>Compiler Explorer：交互式编译器，可以进行汇编输出</li>
<li>CompileOnline：Linux上在线编译和执行C++程序</li>
<li>Ideone ：一个在线编译器和调试工具，允许你在线编译源代码并执行，支持60多种编程语言。</li>
</ul>
<h4 id="调试器"><a href="#调试器" class="headerlink" title="调试器"></a>调试器</h4><p><code>C/C++调试器列表</code></p>
<ul>
<li>Comparison of debuggers ：来自维基百科的调试器列表</li>
<li>GDB ：GNU调试器</li>
<li>Valgrind：内存调试，内存泄露检测，性能分析工具。</li>
</ul>
<h4 id="集成开发环境（IDE）"><a href="#集成开发环境（IDE）" class="headerlink" title="集成开发环境（IDE）"></a>集成开发环境（IDE）</h4><p><code>C/C++集成开发环境列表</code></p>
<ul>
<li>AppCode ：构建与JetBrains’ IntelliJ IDEA 平台上的用于Objective-C，C,C++，Java和Java开发的集成开发环境</li>
<li>CLion：来自JetBrains的跨平台的C/C++的集成开发环境</li>
<li>Code::Blocks ：免费C，C++和Fortran的集成开发环境</li>
<li>CodeLite ：另一个跨平台的免费的C/C++集成开发环境</li>
<li>Dev-C++：可移植的C/C++/C++11集成开发环境</li>
<li>Eclipse CDT：基于Eclipse平台的功能齐全的C和C++集成开发环境</li>
<li>Geany ：轻量级的快速，跨平台的集成开发环境。</li>
<li>IBM VisualAge ：来自IBM的家庭计算机集成开发环境。</li>
<li>Irony-mode：由libclang驱动的用于Emacs的C/C++微模式</li>
<li>KDevelop：免费开源集成开发环境</li>
<li>Microsoft Visual Studio ：来自微软的集成开发环境</li>
<li>NetBeans ：主要用于Java开发的的集成开发环境，也支持其他语言，尤其是PHP，C/C++和HTML5。</li>
<li>Qt Creator：跨平台的C++，Javascript和QML集成开发环境，也是Qt SDK的一部分。</li>
<li>rtags：C/C++的客户端服务器索引，用于 跟基于clang的emacs的集成</li>
<li>Xcode ：由苹果公司开发</li>
<li>YouCompleteMe：一个用于Vim的根据你敲的代码快速模糊搜索并进行代码补全的引擎。</li>
</ul>
<h4 id="构建系统"><a href="#构建系统" class="headerlink" title="构建系统"></a>构建系统</h4><ul>
<li>Bear ：用于为clang工具生成编译数据库的工具</li>
<li>Biicode：基于文件的简单依赖管理器。</li>
<li>CMake ：跨平台的免费开源软件用于管理软件使用独立编译的方法进行构建的过程。</li>
<li>CPM：基于CMake和Git的C++包管理器</li>
<li>FASTBuild：高性能，开源的构建系统，支持高度可扩展性的编译，缓冲和网络分布。</li>
<li>Ninja ：专注于速度的小型构建系统</li>
<li>Scons ：使用Python scipt 配置的软件构建工具</li>
<li>tundra ：高性能的代码构建系统，甚至对于非常大型的软件项目，也能提供最好的增量构建次数。</li>
<li>tup：基于文件的构建系统，用于后台监控变化的文件。</li>
</ul>
<h4 id="静态代码分析"><a href="#静态代码分析" class="headerlink" title="静态代码分析"></a>静态代码分析</h4><p><code>提高质量，减少瑕疵的代码分析工具列表</code></p>
<ul>
<li>Cppcheck ：静态C/C++代码分析工具</li>
<li>include-what-you-use ：使用clang进行代码分析的工具，可以#include在C和C++文件中。</li>
<li>OCLint ：用于C，C++和Objective-C的静态源代码分析工具，用于提高质量，减少瑕疵。</li>
<li>Clang Static Analyzer：查找C，C++和Objective-C程序bug的源代码分析工具</li>
<li>List of tools for static code analysis ：来自维基百科的静态代码分析工具列表</li>
</ul>
<blockquote>
<p>感谢平凡之路和fffaraz 的整理，转载请注明出处。</p>
</blockquote>
]]></content>
      <tags>
        <tag>C</tag>
        <tag>C++</tag>
      </tags>
  </entry>
</search>
